<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PoC Isolado v2.3g - Depuração Mínima</title>
    <style> /* ... (estilos como antes) ... */ </style>
</head>
<body>
    <h1>PoC Isolado v2.3g - Depuração Mínima</h1>
    <button id="runBtn" onclick="runIsolatedTest()">Iniciar Teste Isolado v2.3g</button>
    <div id="output"></div>

    <script>
        // Mantenha AdvancedInt64 e generalUtils se não suspeitar deles
        class AdvancedInt64 { /* ... (código completo como antes) ... */ }
        const generalUtils = { /* ... (código completo como antes) ... */ };

        const outputDivS1 = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const MEDIUM_PAUSE_S1 = 200;

        const logS1 = (message, type = 'info', funcName = '') => {
            console.log(`[CONSOLE LOGS1 ${type.toUpperCase()}] ${funcName ? '['+funcName+'] ' : ''}${message}`);
            const targetDiv = document.getElementById('output');
            if (!targetDiv) {
                console.error("DIV DE LOG 'output' NÃO ENCONTRADO POR logS1");
                return;
            }
            try {
                const timestamp = `[${new Date().toLocaleTimeString()}]`;
                const prefix = funcName ? `[${funcName}] ` : '';
                const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info';
                if(targetDiv.innerHTML.length > 300000){ targetDiv.innerHTML = targetDiv.innerHTML.substring(targetDiv.innerHTML.length - 150000); targetDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + targetDiv.innerHTML; }
                targetDiv.innerHTML += `<span class="log-${logClass}">${timestamp} ${prefix}${sanitizedMessage}\n</span>`;
                targetDiv.scrollTop = targetDiv.scrollHeight;
            } catch(e) { console.error(`Erro DENTRO de logS1:`, e); }
        };

        const PAUSE_S1_FUNC = (ms = 50) => new Promise(r => setTimeout(r, ms));
        // const originalTestObject_f = { simple_key: "simple_value" }; // Comentado por enquanto

        const testPPJsonHijack_v23g = async () => {
            const FNAME = 'testPPJsonHijack_v23g';
            logS1("DEPURANDO: Entrou em testPPJsonHijack_v23g", 'critical', FNAME);
            
            // Comente quase tudo aqui dentro por enquanto
            const ppKey = 'toJSON'; 
            let originalToJSON_Descriptor_g;
            // let ppAppliedSuccessfully_g = false;
            // let callCount_toJSON_g = 0;

            try {
                logS1("DEPURANDO: testPPJsonHijack_v23g - Antes de getOwnPropertyDescriptor", 'critical', FNAME);
                // originalToJSON_Descriptor_g = Object.getOwnPropertyDescriptor(Object.prototype, ppKey); // Potencial ponto de falha
                logS1("DEPURANDO: testPPJsonHijack_v23g - Depois de getOwnPropertyDescriptor (SE EXECUTADO)", 'critical', FNAME);

                // Object.prototype[ppKey] = function() { // Potencial ponto de falha
                //     logS1("DEPURANDO: toJSON Poluído CHAMADO!", 'vuln', FNAME);
                //     return { "dummy_return": true };
                // };
                // ppAppliedSuccessfully_g = true;
                // logS1("DEPURANDO: testPPJsonHijack_v23g - Poluição aplicada (SE EXECUTADO)", 'critical', FNAME);

                // logS1("DEPURANDO: testPPJsonHijack_v23g - Antes de JSON.stringify (SE EXECUTADO)", 'critical', FNAME);
                // const result_g = JSON.stringify({test: "obj"}); 
                // logS1(`DEPURANDO: testPPJsonHijack_v23g - Resultado: ${result_g}`, 'info', FNAME);

            } catch (e) {
                logS1(`DEPURANDO: ERRO em testPPJsonHijack_v23g: ${e.message}`, 'error', FNAME);
                console.error("ERRO testPPJsonHijack_v23g:", e);
            } finally {
                logS1("DEPURANDO: testPPJsonHijack_v23g - Entrou no finally", 'critical', FNAME);
                // Restauração do protótipo comentada por enquanto
            }
            logS1(`DEPURANDO: --- testPPJsonHijack_v23g Concluído ---`, 'test', FNAME);
        };

        const runIsolatedTest = async () => {
            const outputDiv = document.getElementById('output');
            if (outputDiv) outputDiv.innerHTML = '';
            else console.error("Div 'output' não encontrada no início de runIsolatedTest!");

            console.log("runIsolatedTest (v2.3g) FOI CHAMADA! (console)");
            logS1("==== INICIANDO PoC Isolado v2.3g (Depuração Mínima) ====", 'test', 'runIsolatedTest'); // Log na div
            
            try {
                logS1("DEPURANDO: runIsolatedTest - Antes de chamar testPPJsonHijack_v23g", 'critical', 'runIsolatedTest');
                await testPPJsonHijack_v23g();
                logS1("DEPURANDO: runIsolatedTest - Depois de chamar testPPJsonHijack_v23g", 'critical', 'runIsolatedTest');
            } catch (e) {
                logS1(`DEPURANDO: ERRO em runIsolatedTest ao chamar ou aguardar testPPJsonHijack_v23g: ${e.message}`, 'error', 'runIsolatedTest');
                console.error("ERRO runIsolatedTest:", e);
            }
            
            await PAUSE_S1_FUNC(MEDIUM_PAUSE_S1);
            logS1("\n==== PoC Isolado v2.3g CONCLUÍDO ====", 'test', 'runIsolatedTest');
            
            if (runBtn) runBtn.disabled = false; // Habilitar o botão novamente
        };
    </script>
</body>
</html>
