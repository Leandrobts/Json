<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PoC Isolado v2.3L - Object.keys em Todos 'this'</title>
    <style> /* ... estilos como antes ... */ </style>
</head>
<body>
    <h1>PoC Isolado v2.3L - Object.keys em Todos 'this' com Identificação</h1>
    <button onclick="runTest_v23L()">Iniciar Teste v2.3L</button>
    <div id="output"></div>

    <script>
        // AdvancedInt64 e generalUtils como antes...
        class AdvancedInt64 { /* ... (código completo como antes) ... */ }
        const generalUtils = { /* ... (código completo como antes) ... */ };

        const outputDivS1 = document.getElementById('output');
        const MEDIUM_PAUSE_S1 = 200;
        let callCount_toJSON_L = 0;

        const logS1 = (message, type = 'info', funcName = '') => {
            console.log(`[${type.toUpperCase()}] ${funcName ? '['+funcName+'] ' : ''}${message}`);
            // ... (lógica de logS1 para div como antes) ...
            const targetDiv = document.getElementById('output');
            if (targetDiv) {
                try {
                    const timestamp = `[${new Date().toLocaleTimeString()}]`;
                    const prefix = funcName ? `[${funcName}] ` : '';
                    const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info';
                    if(targetDiv.innerHTML.length > 300000){ targetDiv.innerHTML = targetDiv.innerHTML.substring(targetDiv.innerHTML.length - 150000); targetDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + targetDiv.innerHTML; }
                    targetDiv.innerHTML += `<span class="log-${logClass}">${timestamp} ${prefix}${sanitizedMessage}\n</span>`;
                    targetDiv.scrollTop = targetDiv.scrollHeight;
                } catch(e) { console.error(`Erro DENTRO de logS1 (para div):`, e); }
            }
        };
        const PAUSE_S1_FUNC = (ms = 50) => new Promise(r => setTimeout(r, ms));

        const testObject_L = { a: 10, b: 'data_L', c: { nested_L: true, d_L: "deep_L" } };

        let originalToJSON_Descriptor_L;
        const ppKey_L = 'toJSON';

        function setupPrototypePollution_L() {
            callCount_toJSON_L = 0;
            originalToJSON_Descriptor_L = Object.getOwnPropertyDescriptor(Object.prototype, ppKey_L);

            Object.prototype[ppKey_L] = function() {
                callCount_toJSON_L++;
                let logPrefix = `toJSON PoC v2.3L (Call ${callCount_toJSON_L})`;
                
                let thisIdentifier = "unknown_this";
                if (this === testObject_L) thisIdentifier = "ROOT_OBJECT";
                else if (this === testObject_L.c) thisIdentifier = "NESTED_OBJECT_C";
                // Se o 'this' for o array de chaves de uma chamada anterior, a identificação será mais difícil aqui
                // apenas pelo construtor, mas o log do construtor ainda ajuda.
                else if (Array.isArray(this)) thisIdentifier = "ARRAY_OBJECT";


                console.log(`%c${logPrefix} - Invocado! this_id='${thisIdentifier}', typeof='${typeof this}', constructor='${this && this.constructor ? this.constructor.name : 'N/A'}'`, "color:purple");
                logS1(`${logPrefix} - Invocado! this_id='${thisIdentifier}', typeof='${typeof this}', constructor='${this && this.constructor ? this.constructor.name : 'N/A'}'`, 'critical', 'toJSON_L');

                // Tentar console.dir(this) pode ser pesado, mas útil se o log acima não for suficiente
                // console.dir(this);

                let keys = [];
                try {
                    console.log(`%c${logPrefix} - Tentando Object.keys(this) para this_id='${thisIdentifier}'...`, "color:red; font-weight:bold;");
                    keys = Object.keys(this); // A LINHA CRÍTICA
                    console.log(`%c${logPrefix} - Object.keys(this) SUCESSO para this_id='${thisIdentifier}'. Chaves:`, "color:green", keys);
                    logS1(`${logPrefix} - Object.keys(this) SUCESSO para this_id='${thisIdentifier}'. Chaves: [${keys.join(',')}]`, 'good', 'toJSON_L');
                    return { "keys_from_this_id": thisIdentifier, "object_actual_keys": keys };
                } catch (e) {
                    console.error(`${logPrefix} - ERRO em Object.keys(this) para this_id='${thisIdentifier}':`, e);
                    logS1(`${logPrefix} - ERRO em Object.keys(this) para this_id='${thisIdentifier}': ${e.message}`, 'error', 'toJSON_L');
                    return { "error_getting_keys_for_this_id": thisIdentifier, "message": String(e.message) };
                }
            };
            logS1("Poluição Object.prototype.toJSON APLICADA (sempre tenta Object.keys).", 'good', 'setup_L');
        }

        function cleanupPrototypePollution_L() {
            if (originalToJSON_Descriptor_L) {
                Object.defineProperty(Object.prototype, ppKey_L, originalToJSON_Descriptor_L);
            } else if (Object.prototype.hasOwnProperty(ppKey_L)) {
                delete Object.prototype[ppKey_L];
            }
            logS1("Object.prototype.toJSON restaurado.", 'good', 'cleanup_L');
        }

        async function runTest_v23L() {
            document.querySelectorAll('button').forEach(b => b.disabled = true);
            if (outputDivS1) outputDivS1.innerHTML = '';
            logS1(`==== INICIANDO PoC Isolado v2.3L (Object.keys em Todos 'this') ====`, 'test', 'runTest_L');

            setupPrototypePollution_L();
            
            logS1(`Tentando JSON.stringify em testObject_L...`, 'critical', 'runTest_L');
            let result_L;
            try {
                await PAUSE_S1_FUNC(50); 
                result_L = JSON.stringify(testObject_L);
                logS1(`JSON.stringify CONCLUÍDO. Resultado (parcial): ${result_L ? String(result_L).substring(0, 1000) : "N/A"}`, 'good', 'runTest_L');
            } catch (e) {
                logS1(`ERRO CAPTURADO por JSON.stringify: ${e.message}`, 'error', 'runTest_L');
                if (e.stack) logS1(`Stack: ${e.stack}`, 'error', 'runTest_L');
                console.error("ERRO durante JSON.stringify em runTest_L:", e);
            } finally {
                cleanupPrototypePollution_L();
            }
            
            await PAUSE_S1_FUNC(MEDIUM_PAUSE_S1);
            logS1(`\n==== PoC Isolado v2.3L CONCLUÍDO ====`, 'test', 'runTest_L');
            document.querySelectorAll('button').forEach(b => b.disabled = false);
        }
    </script>
</body>
</html>
