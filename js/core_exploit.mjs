// js/core_exploit.mjs
console.log("[CONSOLE_LOG][CORE_EXPLOIT] Módulo core_exploit.mjs carregado.");
import { AdvancedInt64, isAdvancedInt64Object, PAUSE, toHex } from './utils.mjs';
import { logS3 } from './script3/s3_utils.mjs'; // Ajuste o caminho se s3_utils estiver em outro lugar
import { OOB_CONFIG, updateOOBConfigFromUI } from '../config.mjs'; // Caminho para config.mjs a partir de js/

export let oob_array_buffer_real = null;
export let oob_dataview_real = null;

const toHexHelper = (val, bits = 32) => toHex(val, bits); // toHex já está em utils.mjs

export function clearOOBEnvironment() {
    const FNAME_CLEAR = 'CoreExploit.clearOOBEnvironment';
    logS3(`Limpando ambiente OOB...`, 'info', FNAME_CLEAR);
    oob_array_buffer_real = null;
    oob_dataview_real = null;
    logS3(`Ambiente OOB limpo.`, 'good', FNAME_CLEAR);
}

// Funções para obter valores de OOB_CONFIG, atualizando da UI primeiro se aplicável
function ensureOOBConfigUpdated() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined" && document) {
        // console.log("[CONSOLE_LOG][CORE_EXPLOIT] Chamando updateOOBConfigFromUI de ensureOOBConfigUpdated.");
        updateOOBConfigFromUI(document);
    }
}

export function getOOBAllocationSize() {
    ensureOOBConfigUpdated();
    return OOB_CONFIG.ALLOCATION_SIZE;
}
export function getBaseOffsetInDV() {
    ensureOOBConfigUpdated();
    return OOB_CONFIG.BASE_OFFSET_IN_DV;
}


export async function triggerOOB_primitive() {
    const FNAME_TRIGGER = "CoreExploit.triggerOOB_primitive";
    // logS3("Inicializando/Verificando primitiva OOB...", "info", FNAME_TRIGGER);

    ensureOOBConfigUpdated(); // Garante que OOB_CONFIG está atualizado da UI

    if (oob_array_buffer_real && oob_dataview_real) {
        // logS3("Ambiente OOB já inicializado.", "info", FNAME_TRIGGER);
        return;
    }
    // logS3(`Config OOB: AllocSize=${OOB_CONFIG.ALLOCATION_SIZE}, BaseOffsetDV=${OOB_CONFIG.BASE_OFFSET_IN_DV}`, "info", FNAME_TRIGGER);

    try {
        // Simulação da criação da primitiva OOB.
        // Em um exploit real, aqui estaria o código que explora a vulnerabilidade
        // para obter o controle de um ArrayBuffer e DataView.
        oob_array_buffer_real = new ArrayBuffer(OOB_CONFIG.ALLOCATION_SIZE);

        // O DataView "controlado" começa em um offset dentro do ArrayBuffer maior.
        // O bug inicial (não mostrado aqui) permitiria que este DataView
        // acessasse fora de seus limites nominais, mas dentro do oob_array_buffer_real.
        oob_dataview_real = new DataView(oob_array_buffer_real, OOB_CONFIG.BASE_OFFSET_IN_DV, OOB_CONFIG.INITIAL_BUFFER_SIZE);

        // logS3(`oob_array_buffer_real (tamanho: ${oob_array_buffer_real.byteLength}) e oob_dataview_real (offset: ${oob_dataview_real.byteOffset}, tamanho: ${oob_dataview_real.byteLength}) criados.`, "good", FNAME_TRIGGER);

        // Teste básico de escrita/leitura para verificar se as funções OOB funcionam (simulado)
        // await test_oob_read_write_basic(); // Pode ser barulhento, remover para testes focados

    } catch (e) {
        logS3(`ERRO CRÍTICO ao tentar inicializar primitiva OOB: ${e.message}`, "critical", FNAME_TRIGGER);
        console.error(e);
        oob_array_buffer_real = null;
        oob_dataview_real = null;
        throw e; // Re-lança o erro para parar a execução se a primitiva falhar
    }
}

export function oob_read_absolute(absolute_offset, byteLength) {
    // Esta função assume que 'absolute_offset' é relativo ao início do oob_array_buffer_real.
    // Em um exploit real, o DataView 'oob_dataview_real' teria sido corrompido (ou o motor teria sido enganado)
    // para permitir ler do 'absolute_offset' mesmo que esteja fora dos limites originais do DataView.
    // Para esta simulação, criamos um novo DataView temporário sobre o buffer real.
    if (!oob_array_buffer_real) throw new Error("oob_array_buffer_real não inicializado para oob_read_absolute.");
    if (absolute_offset < 0 || absolute_offset + byteLength > oob_array_buffer_real.byteLength) {
        // logS3(`AVISO: oob_read_absolute tentando ler fora dos limites do oob_array_buffer_real. Offset: ${toHex(absolute_offset)}, Comprimento: ${byteLength}`, "warn", "oob_read_absolute");
        // throw new Error("Tentativa de leitura OOB fora dos limites do buffer real simulado.");
        // Em um exploit, isso poderia ser o esperado. Para simulação, podemos permitir ou restringir.
    }

    const temp_dv = new DataView(oob_array_buffer_real); // Vista sobre todo o buffer
    if (byteLength === 1) return temp_dv.getUint8(absolute_offset);
    if (byteLength === 2) return temp_dv.getUint16(absolute_offset, true); // Little-endian
    if (byteLength === 4) return temp_dv.getUint32(absolute_offset, true);
    if (byteLength === 8) {
        const low = temp_dv.getUint32(absolute_offset, true);
        const high = temp_dv.getUint32(absolute_offset + 4, true);
        return new AdvancedInt64(low, high);
    }
    // Para outros tamanhos, retornar Uint8Array
    let result = new Uint8Array(byteLength);
    for (let i = 0; i < byteLength; i++) {
        result[i] = temp_dv.getUint8(absolute_offset + i);
    }
    return result;
}

export function oob_write_absolute(absolute_offset, value, byteLength) {
    if (!oob_array_buffer_real) throw new Error("oob_array_buffer_real não inicializado para oob_write_absolute.");
    if (absolute_offset < 0 || absolute_offset + byteLength > oob_array_buffer_real.byteLength) {
        // logS3(`AVISO: oob_write_absolute tentando escrever fora dos limites do oob_array_buffer_real. Offset: ${toHex(absolute_offset)}, Comprimento: ${byteLength}`, "warn", "oob_write_absolute");
        // throw new Error("Tentativa de escrita OOB fora dos limites do buffer real simulado.");
    }

    const temp_dv = new DataView(oob_array_buffer_real); // Vista sobre todo o buffer
    if (isAdvancedInt64Object(value)) { // Tratar AdvancedInt64
        if (byteLength !== 8) throw new Error("AdvancedInt64 deve ser escrito como 8 bytes.");
        temp_dv.setUint32(absolute_offset, value.low, true);
        temp_dv.setUint32(absolute_offset + 4, value.high, true);
    } else if (value instanceof Uint8Array) {
        for (let i = 0; i < value.length; i++) {
            temp_dv.setUint8(absolute_offset + i, value[i]);
        }
    } else if (typeof value === 'number') {
        if (byteLength === 1) temp_dv.setUint8(absolute_offset, value);
        else if (byteLength === 2) temp_dv.setUint16(absolute_offset, value, true);
        else if (byteLength === 4) temp_dv.setUint32(absolute_offset, value, true);
        else if (byteLength === 8) throw new Error("Para escrita de 8 bytes com número, use AdvancedInt64.");
        else throw new Error(`Tamanho de escrita não suportado para valor numérico: ${byteLength}`);
    } else {
        throw new Error(`Tipo de valor não suportado para oob_write_absolute: ${typeof value}`);
    }
}

// Função de teste (opcional, pode ser barulhenta)
async function test_oob_read_write_basic(currentLog = logS3) {
    const FNAME_TEST = "CoreExploit.test_oob_read_write";
    currentLog("--- Iniciando teste básico de leitura/escrita OOB ---", "subtest", FNAME_TEST);
    try {
        // Escolhe um offset seguro dentro do oob_array_buffer_real, mas fora do oob_dataview_real inicial
        const safe_abs_offset = 0x10; // Exemplo, bem no início do buffer maior
        if (safe_abs_offset + 12 > OOB_CONFIG.ALLOCATION_SIZE) {
            currentLog("AVISO: safe_abs_offset para teste OOB está fora do buffer de alocação.", "warn", FNAME_TEST);
            return;
        }

        const test_val32 = 0x12345678;
        const test_val64 = new AdvancedInt64(0xAABBCCDD, 0x11223344);

        currentLog(`Escrevendo ${toHexHelper(test_val32)} em offset absoluto ${toHexHelper(safe_abs_offset)}`, "info", FNAME_TEST);
        oob_write_absolute(safe_abs_offset, test_val32, 4);
        const read_val32 = oob_read_absolute(safe_abs_offset, 4);
        if (read_val32 === test_val32) {
            currentLog(`SUCESSO: Lido ${toHexHelper(read_val32)} corretamente (32bit).`, "good", FNAME_TEST);
        } else {
            currentLog(`FALHA: Lido ${toHexHelper(read_val32)}, esperado ${toHexHelper(test_val32)}.`, "error", FNAME_TEST);
        }

        const next_abs_offset = safe_abs_offset + 4;
        currentLog(`Escrevendo ${test_val64.toString(true)} em offset absoluto ${toHexHelper(next_abs_offset)}`, "info", FNAME_TEST);
        oob_write_absolute(next_abs_offset, test_val64, 8);
        const read_val64 = oob_read_absolute(next_abs_offset, 8);

        if (isAdvancedInt64Object(read_val64) && read_val64.equals(test_val64)) {
            currentLog(`SUCESSO: Lido ${read_val64.toString(true)} corretamente (64bit).`, "good", FNAME_TEST);
        } else {
            const readValStr = isAdvancedInt64Object(read_val64) ? read_val64.toString(true) : String(read_val64);
            currentLog(`FALHA: Lido ${readValStr}, esperado ${test_val64.toString(true)}.`, "error", FNAME_TEST);
        }

    } catch (e) {
        currentLog(`Erro no teste básico OOB: ${e.message}`, "error", FNAME_TEST);
        console.error(e);
    }
    currentLog("--- Teste básico de leitura/escrita OOB concluído ---", "subtest", FNAME_TEST);
}
