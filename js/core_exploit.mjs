// js/core_exploit.mjs
import { AdvancedInt64, isAdvancedInt64Object, PAUSE, toHex, DataViewUtils } from './utils.mjs'; // ADICIONADO DataViewUtils AQUI
import { logS3 as currentLog } from './script3/s3_utils.mjs';
import { OOB_CONFIG, JSC_OFFSETS, updateOOBConfigFromUI } from './config.mjs';

export let oob_array_buffer_real = null;
export let oob_dataview_real = null;

const toHexHelper = (val, bits = 32) => toHex(val, bits);

export function clearOOBEnvironment() {
    const FNAME_CLEAR = 'CoreExploit.clearOOBEnvironment';
    currentLog(`Limpando ambiente OOB...`, 'info', FNAME_CLEAR);
    oob_array_buffer_real = null;
    oob_dataview_real = null;
    currentLog(`Ambiente OOB limpo.`, 'good', FNAME_CLEAR);
}

export function getOOBAllocationSize() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.ALLOCATION_SIZE;
}
export function getBaseOffsetInDV() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.BASE_OFFSET_IN_DV;
}


export function triggerOOB_primitive() {
    const FNAME_TRIGGER = 'CoreExploit.triggerOOB_primitive';
    currentLog(`--- Iniciando CoreExploit.triggerOOB_primitive ---`, 'test', FNAME_TRIGGER);

    const allocationSize = getOOBAllocationSize();
    const baseOffset = getBaseOffsetInDV();

    currentLog(`    Config OOB: Alloc Size: ${allocationSize}, Base Offset in DV: ${baseOffset}`, 'info', FNAME_TRIGGER);

    if (oob_array_buffer_real && oob_dataview_real) {
        currentLog("    Ambiente OOB já existe. Reutilizando.", "warn", FNAME_TRIGGER);
        // Poderia adicionar uma verificação de tamanho/offset aqui se necessário
        return true;
    }

    try {
        // Criar o ArrayBuffer real que será usado para OOB.
        // O tamanho precisa ser suficiente para cobrir o baseOffset + allocationSize.
        // Adiciona um buffer extra para segurança e para garantir que baseOffset + allocationSize não exceda o buffer.
        const realBufferSize = baseOffset + allocationSize + 256; // 256 de margem
        oob_array_buffer_real = new ArrayBuffer(realBufferSize);

        // Criar a DataView "janela" que permite o acesso OOB (conceitualmente).
        // A DataView aqui é criada sobre o oob_array_buffer_real.
        // O "truque" do OOB geralmente envolve corromper o ponteiro ou tamanho de um ArrayBuffer/DataView
        // para que ele aponte para fora de seus limites pretendidos, ou para que seus limites sejam maiores.
        // Neste contexto simulado/educacional, oob_dataview_real permite acesso direto ao oob_array_buffer_real,
        // e as funções oob_write_absolute/oob_read_absolute simulam o acesso OOB
        // validando os offsets contra os limites do oob_array_buffer_real.
        oob_dataview_real = new DataView(oob_array_buffer_real, baseOffset, allocationSize);

        currentLog(`    oob_array_buffer_real criado com tamanho: ${oob_array_buffer_real.byteLength}`, 'good', FNAME_TRIGGER);
        currentLog(`    oob_dataview_real criado. Offset: ${oob_dataview_real.byteOffset}, Length: ${oob_dataview_real.byteLength}`, 'good', FNAME_TRIGGER);
        currentLog(`--- CoreExploit.triggerOOB_primitive CONCLUÍDO ---`, 'test', FNAME_TRIGGER);
        return true;

    } catch (e) {
        currentLog(`ERRO em triggerOOB_primitive: ${e.message}`, 'critical', FNAME_TRIGGER);
        console.error(e);
        oob_array_buffer_real = null;
        oob_dataview_real = null;
        return false;
    }
}

// Funções de leitura/escrita que operam DIRETAMENTE no oob_array_buffer_real,
// respeitando o BASE_OFFSET_IN_DV como o "início" da nossa janela DataView.
// O offset fornecido para estas funções é RELATIVO ao início do oob_dataview_real.

export function oob_write_absolute(absolute_offset_in_real_ab, value, size_in_bytes = 4) {
    const FNAME_WRITE = "CoreExploit.oob_write_absolute";
    if (!oob_array_buffer_real) {
        currentLog("ERRO: oob_array_buffer_real não inicializado!", "critical", FNAME_WRITE);
        return false;
    }
    if (absolute_offset_in_real_ab < 0 || absolute_offset_in_real_ab + size_in_bytes > oob_array_buffer_real.byteLength) {
        currentLog(`ERRO: Escrita OOB fora dos limites REAIS! Offset: ${toHexHelper(absolute_offset_in_real_ab)}, Size: ${size_in_bytes}, Buffer Size: ${oob_array_buffer_real.byteLength}`, "critical", FNAME_WRITE);
        // Em um exploit real, isso poderia causar um crash se não for o comportamento desejado.
        // Aqui, prevenimos para manter o teste estável.
        return false;
    }

    // Usar uma DataView temporária sobre o oob_array_buffer_real para a escrita
    const temp_dv = new DataView(oob_array_buffer_real);
    try {
        if (size_in_bytes === 1) {
            temp_dv.setUint8(absolute_offset_in_real_ab, Number(value));
        } else if (size_in_bytes === 2) {
            temp_dv.setUint16(absolute_offset_in_real_ab, Number(value), true);
        } else if (size_in_bytes === 4) {
            temp_dv.setUint32(absolute_offset_in_real_ab, Number(value), true);
        } else if (size_in_bytes === 8 && isAdvancedInt64Object(value)) {
            DataViewUtils.writeUint64(temp_dv, absolute_offset_in_real_ab, value);
        } else if (size_in_bytes === 8 && typeof value === 'number') { // Tentativa de escrita de 64-bit de um número JS (arriscado)
             DataViewUtils.writeUint64(temp_dv, absolute_offset_in_real_ab, new AdvancedInt64(value));
        }
        else {
            currentLog(`ERRO: Tamanho de escrita não suportado ou tipo de valor inválido: ${size_in_bytes}`, "error", FNAME_WRITE);
            return false;
        }
        // currentLog(`Escrito ${toHexHelper(value, size_in_bytes*8)} em offset abs ${toHexHelper(absolute_offset_in_real_ab)} (Size: ${size_in_bytes})`, "info", FNAME_WRITE);
        return true;
    } catch (e) {
        currentLog(`ERRO durante oob_write_absolute: ${e.message}`, "error", FNAME_WRITE);
        return false;
    }
}


export function oob_read_absolute(absolute_offset_in_real_ab, size_in_bytes = 4) {
    const FNAME_READ = "CoreExploit.oob_read_absolute";
    if (!oob_array_buffer_real) {
        currentLog("ERRO: oob_array_buffer_real não inicializado!", "critical", FNAME_READ);
        return undefined; // Ou lançar erro
    }
    if (absolute_offset_in_real_ab < 0 || absolute_offset_in_real_ab + size_in_bytes > oob_array_buffer_real.byteLength) {
        currentLog(`ERRO: Leitura OOB fora dos limites REAIS! Offset: ${toHexHelper(absolute_offset_in_real_ab)}, Size: ${size_in_bytes}, Buffer Size: ${oob_array_buffer_real.byteLength}`, "critical", FNAME_READ);
        return undefined; // Ou lançar erro
    }

    const temp_dv = new DataView(oob_array_buffer_real);
    try {
        let val;
        if (size_in_bytes === 1) {
            val = temp_dv.getUint8(absolute_offset_in_real_ab);
        } else if (size_in_bytes === 2) {
            val = temp_dv.getUint16(absolute_offset_in_real_ab, true);
        } else if (size_in_bytes === 4) {
            val = temp_dv.getUint32(absolute_offset_in_real_ab, true);
        } else if (size_in_bytes === 8) {
            val = DataViewUtils.readUint64(temp_dv, absolute_offset_in_real_ab);
        } else {
            currentLog(`ERRO: Tamanho de leitura não suportado: ${size_in_bytes}`, "error", FNAME_READ);
            return undefined;
        }
        // currentLog(`Lido ${toHexHelper(val, size_in_bytes*8)} de offset abs ${toHexHelper(absolute_offset_in_real_ab)} (Size: ${size_in_bytes})`, "info", FNAME_READ);
        return val;
    } catch (e) {
        currentLog(`ERRO durante oob_read_absolute: ${e.message}`, "error", FNAME_READ);
        return undefined;
    }
}

export async function selfTestOOBReadWrite() {
    const FNAME_TEST = 'CoreExploit.selfTestOOBReadWrite';
    currentLog("--- Iniciando Auto-Teste de Leitura/Escrita OOB ---", "test", FNAME_TEST);

    if (!triggerOOB_primitive()) {
        currentLog("Falha ao inicializar ambiente OOB para auto-teste.", "critical", FNAME_TEST);
        return;
    }

    // O offset para teste deve estar dentro dos limites do oob_array_buffer_real.
    // Vamos usar um offset seguro dentro da área do oob_dataview_real para simular um acesso "legítimo" via primitiva.
    const safe_relative_offset = 16; // Relativo ao início do DataView
    const safe_abs_offset = getBaseOffsetInDV() + safe_relative_offset;

    if (safe_abs_offset + 16 > oob_array_buffer_real.byteLength) {
         currentLog("ERRO: Offset de teste excede o tamanho do oob_array_buffer_real. Ajuste getBaseOffsetInDV() ou allocationSize.", "critical", FNAME_TEST);
         return;
    }

    const test_val32 = 0x12345678;
    const test_val64 = new AdvancedInt64(0xAABBCCDD, 0xEEFFAA00);

    currentLog(`Escrevendo ${toHexHelper(test_val32)} em offset absoluto ${toHexHelper(safe_abs_offset)}`, "info", FNAME_TEST);
    oob_write_absolute(safe_abs_offset, test_val32, 4);
    const read_val32 = oob_read_absolute(safe_abs_offset, 4);
    if (read_val32 === test_val32) {
        currentLog(`SUCESSO: Lido ${toHexHelper(read_val32)} corretamente (32bit).`, "good", FNAME_TEST);
    } else {
        currentLog(`FALHA: Lido ${toHexHelper(read_val32)}, esperado ${toHexHelper(test_val32)}.`, "error", FNAME_TEST);
    }

    const next_abs_offset = safe_abs_offset + 4;
    currentLog(`Escrevendo ${test_val64.toString(true)} em offset absoluto ${toHexHelper(next_abs_offset)}`, "info", FNAME_TEST);
    oob_write_absolute(next_abs_offset, test_val64, 8);
    const read_val64 = oob_read_absolute(next_abs_offset, 8);

    if (isAdvancedInt64Object(read_val64) && read_val64.equals(test_val64)) {
        currentLog(`SUCESSO: Lido ${read_val64.toString(true)} corretamente (64bit).`, "good", FNAME_TEST);
    } else {
        const readValStr = isAdvancedInt64Object(read_val64) ? read_val64.toString(true) : String(read_val64);
        currentLog(`FALHA: Lido ${readValStr}, esperado ${test_val64.toString(true)}.`, "error", FNAME_TEST);
    }
    currentLog("--- Auto-Teste de Leitura/Escrita OOB CONCLUÍDO ---", "test", FNAME_TEST);
}
