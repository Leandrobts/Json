// js/core_exploit.mjs
import { AdvancedInt64, isAdvancedInt64Object, PAUSE, toHex } from './utils.mjs';
import { logS3 as log } from './script3/s3_utils.mjs'; 
import { OOB_CONFIG, JSC_OFFSETS, updateOOBConfigFromUI } from './config.mjs';

export let oob_array_buffer_real = null;
export let oob_dataview_real = null;

const toHexHelper = (val, bits = 32) => toHex(val, bits);

export function clearOOBEnvironment() {
    const FNAME_CLEAR = 'CoreExploit.clearOOBEnvironment';
    log(`Limpando ambiente OOB...`, 'info', FNAME_CLEAR);
    oob_array_buffer_real = null;
    oob_dataview_real = null;
    // log(`Ambiente OOB limpo.`, 'good', FNAME_CLEAR); // Removido para reduzir logs se for chamado muitas vezes
}

export function getOOBAllocationSize() { 
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document); 
    }
    return OOB_CONFIG.ALLOCATION_SIZE; 
}
export function getBaseOffsetInDV() { 
    // Esta função pode não ser mais tão relevante se a DataView cobrir o buffer inteiro
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document); 
    }
    return OOB_CONFIG.BASE_OFFSET_IN_DV; 
}
export function getInitialBufferSize() { 
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document); 
    }
    return OOB_CONFIG.INITIAL_BUFFER_SIZE; 
}


export async function triggerOOB_primitive() {
    const FNAME_TRIGGER = 'CoreExploit.triggerOOB_primitive';
    log(`--- Iniciando ${FNAME_TRIGGER} ---`, 'test', FNAME_TRIGGER);
    const currentAllocSize = getOOBAllocationSize();
    // const currentBaseOffset = getBaseOffsetInDV(); // Não mais usado para criar a DataView principal
    // const currentInitialBufSize = getInitialBufferSize(); // Não usado aqui

    log(`   Config OOB: AllocSize=${currentAllocSize}, BaseOffsetDV (original, não usado para DV principal)=${OOB_CONFIG.BASE_OFFSET_IN_DV}`, 'info', FNAME_TRIGGER);

    clearOOBEnvironment(); // Limpa antes de configurar

    try {
        // Criar o ArrayBuffer principal.
        // A DataView pode precisar de padding extra se o tamanho não for múltiplo de 8,
        // mas ArrayBuffer geralmente não se importa.
        // Para garantir que o DataView possa ter o tamanho exato de ALLOCATION_SIZE,
        // o ArrayBuffer pode precisar ser um pouco maior em alguns cenários de engine,
        // mas geralmente new ArrayBuffer(N) dá N bytes.
        oob_array_buffer_real = new ArrayBuffer(currentAllocSize);

        // CORREÇÃO: Criar DataView para cobrir o ArrayBuffer INTEIRO desde o offset 0
        oob_dataview_real = new DataView(oob_array_buffer_real, 0, currentAllocSize);

        log(`Ambiente para Operações OOB CONFIGURADO.`, 'good', FNAME_TRIGGER);
        log(`   oob_array_buffer_real (total): ${oob_array_buffer_real.byteLength} bytes`, 'info', FNAME_TRIGGER);
        log(`   oob_dataview_real (janela controlada): offset=${oob_dataview_real.byteOffset}, length=${oob_dataview_real.byteLength} bytes`, 'info', FNAME_TRIGGER);

    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME_TRIGGER}: ${e.message}`, 'critical', FNAME_TRIGGER);
        console.error(e);
        clearOOBEnvironment(); // Limpar em caso de falha na configuração
        throw e; // Relançar para que o chamador saiba
    }
    log(`--- ${FNAME_TRIGGER} Concluído ---`, 'test', FNAME_TRIGGER);
}


export function oob_read_absolute(absolute_offset, byteLength) {
    const FNAME_READ = 'CoreExploit.oob_read_absolute';
    if (!oob_dataview_real) {
        log(`ERRO: oob_dataview_real não está inicializado para leitura em ${toHexHelper(absolute_offset)}`, "error", FNAME_READ);
        // NÃO chamar clearOOBEnvironment() aqui, apenas retornar ou lançar erro
        throw new Error("oob_dataview_real not initialized for read");
    }

    // Com oob_dataview_real cobrindo o buffer desde o offset 0,
    // absolute_offset É o offset relativo para a DataView.
    const relative_offset = absolute_offset;

    // Verificação de limites (essencial)
    if (relative_offset < 0 || (relative_offset + byteLength) > oob_dataview_real.byteLength) {
        const errorMsg = `Leitura OOB (abs ${toHexHelper(absolute_offset)} -> rel ${toHexHelper(relative_offset)}, tam ${byteLength}) fora dos limites da DataView (0-${oob_dataview_real.byteLength})`;
        log(errorMsg, "error", FNAME_READ);
        throw new RangeError(errorMsg); // Lançar RangeError é apropriado
    }
    
    // log(`DEBUG_CORE_READ${byteLength * 8}: Lendo de offset abs ${toHexHelper(absolute_offset)} (rel ${toHexHelper(relative_offset)})`, 'info', "CoreExploit.ReadAbs");

    try {
        switch (byteLength) {
            case 1: return oob_dataview_real.getUint8(relative_offset);
            case 2: return oob_dataview_real.getUint16(relative_offset, true); // true para little-endian
            case 4: return oob_dataview_real.getUint32(relative_offset, true);
            case 8: {
                const low = oob_dataview_real.getUint32(relative_offset, true);
                const high = oob_dataview_real.getUint32(relative_offset + 4, true);
                const val = new AdvancedInt64(low, high);
                // log(`DEBUG_CORE_READ8: Criado AdvancedInt64: low=${toHexHelper(low)}, high=${toHexHelper(high)}. isAdvInt64=${isAdvancedInt64Object(val)}, val=${val.toString(true)}`, 'info', "CoreExploit.ReadAbs");
                return val;
            }
            default:
                log(`ERRO: Tamanho de leitura inválido: ${byteLength}`, "error", FNAME_READ);
                throw new Error(`Invalid byteLength for read: ${byteLength}`);
        }
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME_READ} ao ler de ${toHexHelper(absolute_offset)} (rel ${toHexHelper(relative_offset)}): ${e.message}`, "critical", FNAME_READ);
        throw e; // Relançar para o chamador tratar
    }
}

export function oob_write_absolute(absolute_offset, value, byteLength) {
    const FNAME_WRITE = 'CoreExploit.oob_write_absolute';
    if (!oob_dataview_real) {
        log(`ERRO: oob_dataview_real não está inicializado para escrita em ${toHexHelper(absolute_offset)}`, "error", FNAME_WRITE);
        // NÃO chamar clearOOBEnvironment() aqui
        throw new Error("oob_dataview_real not initialized for write");
    }

    const relative_offset = absolute_offset; // Pois oob_dataview_real começa em 0

    if (relative_offset < 0 || (relative_offset + byteLength) > oob_dataview_real.byteLength) {
        const errorMsg = `Escrita OOB (abs ${toHexHelper(absolute_offset)} -> rel ${toHexHelper(relative_offset)}, tam ${byteLength}) fora dos limites da DataView (0-${oob_dataview_real.byteLength})`;
        log(errorMsg, "error", FNAME_WRITE);
        throw new RangeError(errorMsg);
    }

    // log(`DEBUG_CORE_WRITE${byteLength * 8}: Escrevendo em offset abs ${toHexHelper(absolute_offset)} (rel ${toHexHelper(relative_offset)})`, 'info', "CoreExploit.WriteAbs");

    try {
        switch (byteLength) {
            case 1: oob_dataview_real.setUint8(relative_offset, Number(value)); break;
            case 2: oob_dataview_real.setUint16(relative_offset, Number(value), true); break;
            case 4: oob_dataview_real.setUint32(relative_offset, Number(value), true); break;
            case 8:
                if (!isAdvancedInt64Object(value)) {
                    throw new TypeError("Valor para escrita de 8 bytes deve ser AdvancedInt64");
                }
                oob_dataview_real.setUint32(relative_offset, value.low(), true);
                oob_dataview_real.setUint32(relative_offset + 4, value.high(), true);
                break;
            default:
                log(`ERRO: Tamanho de escrita inválido: ${byteLength}`, "error", FNAME_WRITE);
                throw new Error(`Invalid byteLength for write: ${byteLength}`);
        }
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME_WRITE} ao escrever em ${toHexHelper(absolute_offset)} (rel ${toHexHelper(relative_offset)}): ${e.message}`, "critical", FNAME_WRITE);
        throw e;
    }
}

// Função de auto-teste (opcional, mas útil)
export async function selfTestOOBReadWrite(logFnParam = log) {
    // ... (código do selfTest como antes, mas agora ele deve funcionar corretamente com os offsets)
    // Exemplo simplificado:
    const FNAME_TEST = 'CoreExploit.selfTestOOBReadWrite';
    currentLog = logFnParam || log;
    currentLog(`--- Iniciando Auto-Teste de OOB R/W ---`, 'test', FNAME_TEST);
    try {
        await triggerOOB_primitive(); // Configura com a DataView corrigida
        
        const test_offset = 0x50; // Um offset seguro dentro do buffer
        const test_val32 = 0x11223344;
        const test_val64 = new AdvancedInt64(0xAABBCCDD, 0xEEFF0011);

        currentLog(`Escrevendo ${toHexHelper(test_val32)} em offset absoluto ${toHexHelper(test_offset)}`, "info", FNAME_TEST);
        oob_write_absolute(test_offset, test_val32, 4);
        const read_val32 = oob_read_absolute(test_offset, 4);
        if (read_val32 === test_val32) {
            currentLog(`SUCESSO: Lido ${toHexHelper(read_val32)} corretamente (32bit).`, "good", FNAME_TEST);
        } else {
            currentLog(`FALHA: Lido ${toHexHelper(read_val32)}, esperado ${toHexHelper(test_val32)}.`, "error", FNAME_TEST); throw new Error("Self-test 32bit failed");
        }

        const next_offset = test_offset + 8;
        currentLog(`Escrevendo ${test_val64.toString(true)} em offset absoluto ${toHexHelper(next_offset)}`, "info", FNAME_TEST);
        oob_write_absolute(next_offset, test_val64, 8);
        const read_val64 = oob_read_absolute(next_offset, 8);
        if (isAdvancedInt64Object(read_val64) && read_val64.equals(test_val64)) {
            currentLog(`SUCESSO: Lido ${read_val64.toString(true)} corretamente (64bit).`, "good", FNAME_TEST);
        } else {
            currentLog(`FALHA: Lido ${isAdvancedInt64Object(read_val64) ? read_val64.toString(true) : String(read_val64)}, esperado ${test_val64.toString(true)}.`, "error", FNAME_TEST); throw new Error("Self-test 64bit failed");
        }
        currentLog(`--- Auto-Teste de OOB R/W Concluído ---`, 'test', FNAME_TEST);
        return true;
    } catch (e) {
        currentLog(`ERRO no Auto-Teste OOB R/W: ${e.message}`, 'critical', FNAME_TEST);
        return false;
    }
}
let currentLog = log; // Para o selfTest
